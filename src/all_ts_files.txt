===== ./app.controller.spec.ts =====
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
\n
===== ./app.controller.ts =====
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
\n
===== ./app.module.ts =====
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { ThrottlerModule } from '@nestjs/throttler';

import { LoggerModule } from './shared/infrastructure/logger/logger.module';
import { ExceptionsModule } from './shared/infrastructure/exceptions/exceptions.module';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { RolesModule } from './roles/roles.module';
import { PropertiesModule } from './properties/properties.module';
import { ImagesModule } from './images/images.module';
import { ContactModule } from './contact/contact.module';
import { MetricsModule } from './metrics/metrics.module';
import { TenantsModule } from './tenants/tenants.module';
import { SeedsModule } from './seeds/seeds.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: process.env.NODE_ENV 
        ? `.env.${process.env.NODE_ENV}` 
        : ['.env.development', '.env'],
      expandVariables: true,
      validationOptions: {
        allowUnknown: false,
        abortEarly: true,
      },
    }),
    ThrottlerModule.forRoot([{
      ttl: 60000,
      limit: 100,
    }]),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        uri: configService.get<string>('MONGODB_URI', 'mongodb://localhost:27017/property_listing'),
      }),
      inject: [ConfigService],
    }),
    LoggerModule,
    ExceptionsModule,
    AuthModule,
    UsersModule,
    RolesModule,
    PropertiesModule,
    ImagesModule,
    ContactModule,
    MetricsModule,
    TenantsModule,
    SeedsModule,
  ],
})
export class AppModule {}\n
===== ./app.service.ts =====
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
\n
===== ./auth/auth.controller.ts =====

import { Controller, Post, Body, UseGuards, Request, ValidationPipe } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { RegisterDto } from 'src/roles/dto/register.dto';


@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(@Request() req) {
    return this.authService.login(req.user);
  }

  @Post('register')
  async register(@Body(new ValidationPipe({ whitelist: true })) registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }
}\n
===== ./auth/auth.module.ts =====
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { UsersModule } from '../users/users.module';
import { RolesModule } from 'src/roles/roles.module';

@Module({
  imports: [
    UsersModule,
    RolesModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => {
        const secret = configService.get<string>('JWT_SECRET');
        if (!secret) {
          console.warn('WARNING: JWT_SECRET not found in environment variables. Using fallback secret.');
          return {
            secret: 'fallback-secret-key-change-this-in-production',
            signOptions: { 
              expiresIn: configService.get<string>('JWT_EXPIRATION', '7d') as any
            },
          };
        }
        const expiresIn = configService.get<string>('JWT_EXPIRATION', '7d');
        return {
          secret,
          signOptions: { 
            expiresIn: expiresIn as any 
          },
        };
      },
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}\n
===== ./auth/auth.service.ts =====
import { Injectable, UnauthorizedException, BadRequestException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import { CreateUserDto } from '../users/dto/create-user.dto';
import { RegisterDto } from 'src/roles/dto/register.dto';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.usersService.validateUser(email, password);
    
    if (user) {
      const permissions = await this.usersService.getUserPermissions(user._id.toString());
      const safeUser = user.toSafeObject();
      return {
        ...safeUser,
        permissions,
      };
    }
    return null;
  }

  async login(user: any) {
    const permissions = await this.usersService.getUserPermissions(user._id);
    
    const payload = { 
      email: user.email, 
      sub: user._id,
      permissions,
      tenantId: user.tenant?.toString() || user.tenantId,
    };
    
    return {
      access_token: this.jwtService.sign(payload),
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        permissions,
        tenantId: user.tenant?.toString() || user.tenantId,
      },
    };
  }

  async register(registerDto: RegisterDto) {
    // Check if user already exists
    const existingUser = await this.usersService.findByEmail(registerDto.email);
    if (existingUser) {
      throw new BadRequestException('User with this email already exists');
    }

    // Convert RegisterDto to CreateUserDto
    const createUserDto: CreateUserDto = {
      name: registerDto.name,
      email: registerDto.email,
      password: registerDto.password,
      metadata: {
        phone: registerDto.phone,
      },
    };

    // Create user with default role
    const user = await this.usersService.create(createUserDto);
    
    // Get permissions for the created user
    const permissions = await this.usersService.getUserPermissions(user._id.toString());
    const safeUser = user.toSafeObject();
    
    return this.login({
      ...safeUser,
      permissions,
      _id: user._id.toString(),
      tenant: user.tenant,
    });
  }
}\n
===== ./auth/decorators/get-user.decorator.ts =====
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);\n
===== ./auth/decorators/permissions.decorator.ts =====
import { SetMetadata } from '@nestjs/common';
import { Permission } from '../../shared/constants/permissions';

export const PERMISSIONS_KEY = 'permissions';

export const RequirePermissions = (...permissions: Permission[]) => 
  SetMetadata(PERMISSIONS_KEY, permissions);\n
===== ./auth/guards/jwt-auth.guard.ts =====
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}\n
===== ./auth/guards/local-auth.guard.ts =====
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}\n
===== ./auth/guards/permissions.guard.ts =====
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { PERMISSIONS_KEY } from '../decorators/permissions.decorator';
import { Permission } from '../../shared/constants/permissions';

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.getAllAndOverride<Permission[]>(
      PERMISSIONS_KEY,
      [context.getHandler(), context.getClass()],
    );
    
    if (!requiredPermissions || requiredPermissions.length === 0) {
      return true;
    }
    
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    
    if (!user) {
      throw new ForbiddenException('Authentication required');
    }
    
    const hasAllPermissions = requiredPermissions.every(permission =>
      user.permissions?.includes(permission),
    );

    if (!hasAllPermissions) {
      throw new ForbiddenException(
        `Insufficient permissions. Required: ${requiredPermissions.join(', ')}`,
      );
    }

    return true;
  }
}\n
===== ./auth/strategies/jwt.strategy.ts =====
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { JwtPayload, AuthenticatedUser } from '../../common/types';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    const secret = configService.get<string>('JWT_SECRET');
    
    if (!secret && process.env.NODE_ENV === 'production') {
      throw new Error('JWT_SECRET must be set in production environment');
    }
    
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: secret || 'development-secret-only',
    });
  }

  async validate(payload: JwtPayload): Promise<AuthenticatedUser> {
    return { 
      userId: payload.sub, 
      email: payload.email, 
      permissions: payload.permissions,
      tenantId: payload.tenantId,
    };
  }
}\n
===== ./auth/strategies/local.strategy.ts =====
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}\n
===== ./common/interfaces/request.interface.ts =====

import { Request } from 'express';
import { TenantDocument } from '../../tenants/schemas/tenant.schema';

export interface IRequestWithTenant extends Request {
  tenant?: TenantDocument;
  tenantId?: string;
}\n
===== ./common/types/index.ts =====
import { Types } from 'mongoose';
import { Permission } from '../../shared/constants/permissions';

export interface JwtPayload {
  email: string;
  sub: string;
  permissions: Permission[];
  tenantId: string;
}

export interface AuthenticatedUser {
  userId: string;
  email: string;
  name?: string;
  permissions: Permission[];
  tenantId?: string;
}

export interface CloudinaryResponse {
  secure_url: string;
  public_id: string;
  version: number;
  signature: string;
  width: number;
  height: number;
  format: string;
  resource_type: string;
  created_at: string;
  bytes: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface Coordinates {
  lng: number;
  lat: number;
}\n
===== ./config/cloudinary.config.ts =====
import { v2 as cloudinary } from 'cloudinary';

export const CloudinaryConfig = {
  provide: 'CLOUDINARY',
  useFactory: () => {
    return cloudinary.config({
      cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
      api_key: process.env.CLOUDINARY_API_KEY,
      api_secret: process.env.CLOUDINARY_API_SECRET,
    });
  },
};\n
===== ./config/env.validation.ts =====
import { plainToClass } from 'class-transformer';
import { IsEnum, IsString, validateSync, IsOptional, IsNumber } from 'class-validator';

enum Environment {
  Development = 'development',
  Production = 'production',
  Test = 'test',
}

class EnvironmentVariables {
  @IsEnum(Environment)
  NODE_ENV: Environment;

  @IsString()
  MONGODB_URI: string;

  @IsString()
  JWT_SECRET: string;

  @IsOptional()
  @IsString()
  JWT_EXPIRATION?: string = '7d';

  @IsOptional()
  @IsString()
  CLOUDINARY_CLOUD_NAME?: string;

  @IsOptional()
  @IsString()
  CLOUDINARY_API_KEY?: string;

  @IsOptional()
  @IsString()
  CLOUDINARY_API_SECRET?: string;

  @IsOptional()
  @IsString()
  FRONTEND_URL?: string = 'http://localhost:3001';

  @IsOptional()
  @IsNumber()
  PORT?: number = 3000;

  @IsOptional()
  @IsString()
  ADMIN_EMAIL?: string;

  @IsOptional()
  @IsString()
  ADMIN_PASSWORD?: string;

  @IsOptional()
  @IsString()
  ADMIN_NAME?: string = 'Super Admin';

  @IsOptional()
  @IsString()
  DEFAULT_TENANT_SLUG?: string = 'main';

  @IsOptional()
  @IsString()
  DEFAULT_TENANT_NAME?: string = 'Main Platform';

  @IsOptional()
  @IsString()
  SMTP_HOST?: string;

  @IsOptional()
  @IsNumber()
  SMTP_PORT?: number = 587;

  @IsOptional()
  @IsString()
  SMTP_USER?: string;

  @IsOptional()
  @IsString()
  SMTP_PASS?: string;

  @IsOptional()
  @IsString()
  EMAIL_FROM?: string = 'Property Listing <noreply@example.com>';
}

export function validateEnv(config: Record<string, unknown>) {
  const validatedConfig = plainToClass(EnvironmentVariables, config, {
    enableImplicitConversion: true,
  });
  
  const errors = validateSync(validatedConfig, {
    skipMissingProperties: false,
  });

  if (errors.length > 0) {
    const missingVars = errors
      .map(error => Object.values(error.constraints || {}))
      .flat()
      .join(', ');
    
    if (process.env.NODE_ENV === 'production') {
      throw new Error(`Missing or invalid environment variables: ${missingVars}`);
    } else {
      console.warn('Environment validation warnings:', missingVars);
    }
  }

  return validatedConfig;
}\n
===== ./contact/contact.controller.ts =====
import { Controller, Post, Body, Get, Param, Delete, Patch, UseGuards, Query } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { PermissionsGuard } from '../auth/guards/permissions.guard';
import { RequirePermissions } from '../auth/decorators/permissions.decorator';
import { GetUser } from '../auth/decorators/get-user.decorator';
import { Permission } from '../shared/constants/permissions';
import { ContactService } from './contact.service';
import { CreateContactDto } from './dto/create-contact.dto';

@Controller('contact')
export class ContactController {
  constructor(private readonly contactService: ContactService) {}

  @Post()
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_READ_OWN)
  async create(
    @Body() createContactDto: CreateContactDto,
    @GetUser() user: any,
  ) {
    return this.contactService.createContact(createContactDto, user.userId);
  }

  @Get()
  @UseGuards(JwtAuthGuard)
  async getContacts(
    @GetUser() user: any,
    @Query('type') type: 'received' | 'sent' = 'received',
  ) {
    return this.contactService.getUserContacts(user.userId, type);
  }

  @Get('unread-count')
  @UseGuards(JwtAuthGuard)
  async getUnreadCount(@GetUser() user: any) {
    const count = await this.contactService.getUnreadCount(user.userId);
    return { count };
  }

  @Patch(':id/read')
  @UseGuards(JwtAuthGuard)
  async markAsRead(
    @Param('id') id: string,
    @GetUser() user: any,
  ) {
    return this.contactService.markAsRead(id, user.userId);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  async delete(
    @Param('id') id: string,
    @GetUser() user: any,
  ) {
    await this.contactService.deleteContact(id, user.userId);
    return { message: 'Contact deleted successfully' };
  }
}\n
===== ./contact/contact.module.ts =====

import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ContactController } from './contact.controller';
import { ContactService } from './contact.service';
import { Contact, ContactSchema } from './schemas/contact.schema';
import { UsersModule } from '../users/users.module';
import { PropertyEntity, PropertySchema } from '../properties/persistence/property/property.entity';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Contact.name, schema: ContactSchema },
      { name: PropertyEntity.name, schema: PropertySchema },
    ]),
    UsersModule,
  ],
  controllers: [ContactController],
  providers: [ContactService],
  exports: [ContactService],
})
export class ContactModule {}\n
===== ./contact/contact.service.ts =====

import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Contact, ContactDocument } from './schemas/contact.schema';
import { CreateContactDto } from './dto/create-contact.dto';
import { UsersService } from '../users/users.service';
import { PropertyEntity, PropertyDocument } from '../properties/persistence/property/property.entity';

@Injectable()
export class ContactService {
  constructor(
    @InjectModel(Contact.name) private contactModel: Model<ContactDocument>,
    private usersService: UsersService,
    @InjectModel(PropertyEntity.name) private propertyModel: Model<PropertyDocument>,
  ) {}

  async createContact(createContactDto: CreateContactDto, fromUserId: string): Promise<ContactDocument> {
    // Get the property to find the owner
    const property = await this.propertyModel.findById(createContactDto.propertyId);
    if (!property) {
      throw new NotFoundException('Property not found');
    }

    // Check if property is published
    if (property.status !== 'published') {
      throw new NotFoundException('Property is not available for contact');
    }

    // Get property owner
    const ownerId = property.owner.toString();

    // Create contact message
    const contact = new this.contactModel({
      property: new Types.ObjectId(createContactDto.propertyId),
      fromUser: new Types.ObjectId(fromUserId),
      toUser: new Types.ObjectId(ownerId),
      name: createContactDto.name,
      email: createContactDto.email,
      phone: createContactDto.phone,
      message: createContactDto.message,
    });

    return contact.save();
  }

  async getUserContacts(userId: string, type: 'received' | 'sent' = 'received'): Promise<ContactDocument[]> {
    const query = type === 'received' 
      ? { toUser: new Types.ObjectId(userId), deletedAt: null }
      : { fromUser: new Types.ObjectId(userId), deletedAt: null };

    return this.contactModel
      .find(query)
      .populate('property', 'title images location')
      .populate('fromUser', 'name email')
      .populate('toUser', 'name email')
      .sort({ createdAt: -1 })
      .exec();
  }

  async markAsRead(contactId: string, userId: string): Promise<ContactDocument> {
    const contact = await this.contactModel.findOneAndUpdate(
      { 
        _id: contactId, 
        toUser: new Types.ObjectId(userId),
        isRead: false 
      },
      { 
        isRead: true,
        readAt: new Date()
      },
      { new: true }
    );

    if (!contact) {
      throw new NotFoundException('Contact not found or already read');
    }

    return contact;
  }

  async deleteContact(contactId: string, userId: string): Promise<void> {
    const contact = await this.contactModel.findOne({
      _id: contactId,
      $or: [
        { fromUser: new Types.ObjectId(userId) },
        { toUser: new Types.ObjectId(userId) }
      ]
    });

    if (!contact) {
      throw new NotFoundException('Contact not found');
    }

    contact.deletedAt = new Date();
    await contact.save();
  }

  async getUnreadCount(userId: string): Promise<number> {
    return this.contactModel.countDocuments({
      toUser: new Types.ObjectId(userId),
      isRead: false,
      deletedAt: null
    });
  }
}\n
===== ./contact/dto/create-contact.dto.ts =====
import { IsString, IsEmail, IsNotEmpty, IsMongoId, IsOptional } from 'class-validator';

export class CreateContactDto {
  @IsMongoId()
  @IsNotEmpty()
  propertyId: string;

  @IsString()
  @IsNotEmpty()
  name: string;

  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsOptional()
  phone?: string;

  @IsString()
  @IsNotEmpty()
  message: string;
}\n
===== ./contact/schemas/contact.schema.ts =====

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type ContactDocument = Contact & Document;

@Schema({ timestamps: true })
export class Contact {
  @Prop({ type: Types.ObjectId, ref: 'Property', required: true })
  property: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  fromUser: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  toUser: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  email: string;

  @Prop()
  phone?: string;

  @Prop({ required: true })
  message: string;

  @Prop({ default: false })
  isRead: boolean;

  @Prop()
  readAt?: Date;

  @Prop()
  deletedAt?: Date;

  createdAt: Date;
  updatedAt: Date;
}

export const ContactSchema = SchemaFactory.createForClass(Contact);

// Indexes
ContactSchema.index({ property: 1 });
ContactSchema.index({ fromUser: 1 });
ContactSchema.index({ toUser: 1 });
ContactSchema.index({ isRead: 1 });
ContactSchema.index({ createdAt: -1 });\n
===== ./images/images.controller.ts =====
import { 
  Controller, 
  Post, 
  UseInterceptors, 
  UploadedFiles, 
  UseGuards, 
  BadRequestException,
  Delete,
  Body,
  Param,
} from '@nestjs/common';
import { FilesInterceptor } from '@nestjs/platform-express';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { PermissionsGuard } from '../auth/guards/permissions.guard';
import { RequirePermissions } from '../auth/decorators/permissions.decorator';
import { Permission } from '../shared/constants/permissions';
import { ImagesService } from './images.service';
import { GetUser } from '../auth/decorators/get-user.decorator';

@Controller('images')
@UseGuards(JwtAuthGuard)
export class ImagesController {
  constructor(private readonly imagesService: ImagesService) {}

  @Post('upload')
  @UseGuards(PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_CREATE, Permission.PROPERTY_UPDATE_OWN)
  @UseInterceptors(FilesInterceptor('images', 10))
  async uploadImages(
    @UploadedFiles() files: Express.Multer.File[],
    @GetUser() user: any,
  ) {
    if (!files || files.length === 0) {
      throw new BadRequestException('No files uploaded');
    }

    try {
      const folder = `property-listings/tenant-${user.tenantId || 'default'}/user-${user.userId}`;
      
      const urls = await this.imagesService.uploadMultipleImages(files, folder);
      return { 
        success: true,
        urls,
        count: urls.length,
        message: 'Images uploaded successfully' 
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  @Delete('delete')
  @UseGuards(PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_UPDATE_OWN, Permission.PROPERTY_UPDATE_ALL)
  async deleteImages(@Body() body: { urls: string[] }) {
    if (!body.urls || !Array.isArray(body.urls) || body.urls.length === 0) {
      throw new BadRequestException('No image URLs provided');
    }

    try {
      await this.imagesService.deleteMultipleImages(body.urls);
      return { 
        success: true,
        message: 'Images deleted successfully',
        deletedCount: body.urls.length 
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  @Post('optimize')
  async optimizeImage(@Body() body: { url: string; options?: any }) {
    if (!body.url) {
      throw new BadRequestException('Image URL is required');
    }

    try {
      const publicId = this.imagesService['extractPublicId'](body.url);
      const optimizedUrl = this.imagesService.generateOptimizedUrl(publicId, body.options);
      
      return {
        success: true,
        originalUrl: body.url,
        optimizedUrl,
        publicId,
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }
}\n
===== ./images/images.module.ts =====
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { ImagesService } from './images.service';
import { ImagesController } from './images.controller';
import { CloudinaryConfig } from '../config/cloudinary.config';

@Module({
  imports: [ConfigModule],
  controllers: [ImagesController],
  providers: [ImagesService, CloudinaryConfig],
  exports: [ImagesService],
})
export class ImagesModule {}\n
===== ./images/images.service.ts =====
import { Injectable, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { v2 as cloudinary, UploadApiResponse, UploadApiErrorResponse } from 'cloudinary';
import * as stream from 'stream';

@Injectable()
export class ImagesService {
  constructor(private configService: ConfigService) {
    // Configure Cloudinary
    cloudinary.config({
      cloud_name: this.configService.get<string>('CLOUDINARY_CLOUD_NAME'),
      api_key: this.configService.get<string>('CLOUDINARY_API_KEY'),
      api_secret: this.configService.get<string>('CLOUDINARY_API_SECRET'),
    });
  }

  validateFile(file: Express.Multer.File): void {
    const maxSize = this.configService.get<number>('MAX_FILE_SIZE', 5242880); // 5MB
    const allowedTypes = this.configService
      .get<string>('ALLOWED_FILE_TYPES', 'image/jpeg,image/png,image/webp')
      .split(',');

    if (file.size > maxSize) {
      throw new BadRequestException(`File size must be less than ${maxSize / 1024 / 1024}MB`);
    }

    if (!allowedTypes.includes(file.mimetype)) {
      throw new BadRequestException(`File type not allowed. Allowed types: ${allowedTypes.join(', ')}`);
    }
  }

  async uploadImage(file: Express.Multer.File, folder: string = 'property-listings'): Promise<string> {
    this.validateFile(file);

    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: folder,
          transformation: [
            { width: 1200, height: 800, crop: 'limit' },
            { quality: 'auto:good' },
          ],
          resource_type: 'auto',
        },
        (error: UploadApiErrorResponse | undefined, result: UploadApiResponse | undefined) => {
          if (error) {
            reject(new BadRequestException(`Failed to upload image: ${error.message}`));
          } else if (result && result.secure_url) {
            resolve(result.secure_url);
          } else {
            reject(new BadRequestException('No result from Cloudinary'));
          }
        },
      );

      const readableStream = new stream.Readable();
      readableStream.push(file.buffer);
      readableStream.push(null);
      readableStream.pipe(uploadStream);
    });
  }

  async uploadMultipleImages(files: Express.Multer.File[], folder?: string): Promise<string[]> {
    const uploadPromises = files.map((file) => this.uploadImage(file, folder));
    return Promise.all(uploadPromises);
  }

  async deleteImage(imageUrl: string): Promise<void> {
    try {
      const publicId = this.extractPublicId(imageUrl);
      await cloudinary.uploader.destroy(publicId);
    } catch (error) {
      console.error('Failed to delete image:', error);
      throw new BadRequestException('Failed to delete image');
    }
  }

  async deleteMultipleImages(imageUrls: string[]): Promise<void> {
    const deletePromises = imageUrls.map(url => this.deleteImage(url).catch(err => {
      console.error(`Failed to delete image ${url}:`, err);
      return null;
    }));
    
    await Promise.all(deletePromises);
  }

  private extractPublicId(url: string): string {
    try {
      // Extract public_id from Cloudinary URL
      const urlParts = url.split('/');
      const filenameWithExtension = urlParts[urlParts.length - 1];
      const filenameWithoutExtension = filenameWithExtension.split('.')[0];
      
      // Find the folder name
      const uploadIndex = urlParts.indexOf('upload');
      if (uploadIndex > -1) {
        const folderParts = urlParts.slice(uploadIndex + 2, -1);
        if (folderParts.length > 0) {
          return `${folderParts.join('/')}/${filenameWithoutExtension}`;
        }
      }
      
      return `property-listings/${filenameWithoutExtension}`;
    } catch (error) {
      throw new BadRequestException('Invalid Cloudinary URL');
    }
  }

  // Helper to generate optimized URLs
  generateOptimizedUrl(publicId: string, options: any = {}): string {
    const defaultOptions = {
      fetch_format: 'auto',
      quality: 'auto',
      width: 800,
      height: 600,
      crop: 'fill',
    };
    
    return cloudinary.url(publicId, { ...defaultOptions, ...options });
  }
}\n
===== ./main.ts =====
import { ValidationPipe, Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

import helmet from 'helmet';

import { AppModule } from './app.module';
import { LoggerService } from './shared/infrastructure/logger/logger.service';
import { AllExceptionFilter } from './shared/infrastructure/filter/exception.filter';
import { HttpExceptionFilter } from './shared/infrastructure/filter/http-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    logger: new LoggerService(),
    cors: {
      origin: process.env.FRONTEND_URL?.split(',') || ['http://localhost:3001'],
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Tenant-ID'],
    },
  });

  // Security middleware
  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https://res.cloudinary.com"],
        connectSrc: ["'self'", process.env.FRONTEND_URL || 'http://localhost:3001'],
      },
    },
    crossOriginEmbedderPolicy: false,
  }));
  
  // app.use(compression());
  
  // Rate limiting
  // const limiter = rateLimit({
  //   windowMs: 15 * 60 * 1000, // 15 minutes
  //   max: 100, // limit each IP to 100 requests per windowMs
  //   message: 'Too many requests from this IP, please try again later.',
  // });
  
  // Apply rate limiting to all routes except auth
  // app.use((req, res, next) => {
  //   if (req.path.startsWith('/api/v1/auth/')) {
  //     return next();
  //   }
  //   limiter(req, res, next);
  // });

  // Global pipes
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Global filters
  app.useGlobalFilters(new AllExceptionFilter(new LoggerService()));
  app.useGlobalFilters(new HttpExceptionFilter());

  // Global prefix
  app.setGlobalPrefix('api/v1');

  // Health check endpoint
  app.getHttpAdapter().get('/health', (req, res) => {
    res.status(200).json({
      status: 'ok',
      timestamp: new Date().toISOString(),
      service: 'Property Listing API',
      version: '1.0.0',
      uptime: process.uptime(),
      environment: process.env.NODE_ENV,
    });
  });

  // Swagger documentation
  if (process.env.NODE_ENV !== 'production') {
    const config = new DocumentBuilder()
      .setTitle('Property Listing API')
      .setDescription('Multi-tenant property listing platform with permission-based access control')
      .setVersion('1.0')
      .addBearerAuth()
      .addApiKey({ type: 'apiKey', name: 'X-Tenant-ID', in: 'header' }, 'tenant-id')
      .addTag('Auth', 'Authentication endpoints')
      .addTag('Users', 'User management')
      .addTag('Properties', 'Property listing and management')
      .addTag('Images', 'Image upload and management')
      .addTag('Tenants', 'Tenant management')
      .addTag('Contact', 'Property contact messages')
      .addTag('Metrics', 'System metrics and analytics')
      .build();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup('api/docs', app, document, {
      swaggerOptions: {
        persistAuthorization: true,
        docExpansion: 'none',
        tagsSorter: 'alpha',
        operationsSorter: 'alpha',
      },
      customSiteTitle: 'Property Listing API Documentation',
    });
  }

  const port = process.env.PORT || 3000;
  await app.listen(port);

  Logger.log(`üöÄ Application is running on: http://localhost:${port}`, 'Bootstrap');
  if (process.env.NODE_ENV !== 'production') {
    Logger.log(`üìö Swagger docs available at: http://localhost:${port}/api/docs`, 'Bootstrap');
  }
  Logger.log(`üè• Health check at: http://localhost:${port}/health`, 'Bootstrap');
}

bootstrap();\n
===== ./metrics/metrics.controller.ts =====
import { Controller, Get, UseGuards, Query } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth, ApiQuery } from '@nestjs/swagger';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { PermissionsGuard } from 'src/auth/guards/permissions.guard';
import { MetricsService } from './metrics.service';
import { RequirePermissions } from 'src/auth/decorators/permissions.decorator';
import { Permission } from 'src/shared/constants/permissions';
import { GetUser } from 'src/auth/decorators/get-user.decorator';


@ApiTags('Metrics')
@ApiBearerAuth()
@Controller('metrics')
@UseGuards(JwtAuthGuard, PermissionsGuard)
export class MetricsController {
  constructor(private readonly metricsService: MetricsService) {}

  @Get('system')
  @RequirePermissions(Permission.SYSTEM_METRICS_READ)
  @ApiOperation({ summary: 'Get system-wide metrics (Admin only)' })
  @ApiResponse({ status: 200, description: 'System metrics retrieved' })
  @ApiResponse({ status: 403, description: 'Forbidden - Admin access required' })
  async getSystemMetrics() {
    return this.metricsService.getSystemMetrics();
  }

  @Get('property')
  @RequirePermissions(Permission.SYSTEM_METRICS_READ)
  @ApiOperation({ summary: 'Get property engagement metrics' })
  @ApiQuery({ name: 'timeRange', enum: ['day', 'week', 'month'], required: false })
  @ApiResponse({ status: 200, description: 'Property metrics retrieved' })
  @ApiResponse({ status: 403, description: 'Forbidden - Admin access required' })
  async getPropertyMetrics(
    @Query('timeRange') timeRange: 'day' | 'week' | 'month' = 'week',
  ) {
    return this.metricsService.getPropertyMetrics(timeRange);
  }

  @Get('tenant')
  @RequirePermissions(Permission.SYSTEM_METRICS_READ)
  @ApiOperation({ summary: 'Get tenant-specific metrics' })
  @ApiResponse({ status: 200, description: 'Tenant metrics retrieved' })
  @ApiResponse({ status: 403, description: 'Forbidden - Admin access required' })
  async getTenantMetrics(@GetUser() user: any) {
    const tenantId = user.tenantId || user.tenant?.toString();
    return this.metricsService.getTenantMetrics(tenantId);
  }
}\n
===== ./metrics/metrics.module.ts =====
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MetricsService } from './metrics.service';
import { PropertyEntity, PropertySchema } from '../properties/persistence/property/property.entity';
import { User, UserSchema } from '../users/schemas/user.schema';
import { Contact, ContactSchema } from '../contact/schemas/contact.schema';
import { Role, RoleSchema } from '../roles/schemas/role.schema';
import { Tenant, TenantSchema } from '../tenants/schemas/tenant.schema';
import { MetricsController } from './metrics.controller';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: PropertyEntity.name, schema: PropertySchema },
      { name: User.name, schema: UserSchema },
      { name: Contact.name, schema: ContactSchema },
      { name: Role.name, schema: RoleSchema },
      { name: Tenant.name, schema: TenantSchema },
    ]),
  ],
  controllers: [MetricsController],
  providers: [MetricsService],
  exports: [MetricsService],
})
export class MetricsModule {}\n
===== ./metrics/metrics.service.ts =====

import { Injectable, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { PropertyEntity, PropertyDocument } from '../properties/persistence/property/property.entity';
import { User, UserDocument } from '../users/schemas/user.schema';
import { Contact, ContactDocument } from '../contact/schemas/contact.schema';
import { Role, RoleDocument } from '../roles/schemas/role.schema';
import { Tenant, TenantDocument } from '../tenants/schemas/tenant.schema';
import { PropertyStatus } from '../properties/domain/property/Property';


@Injectable()
export class MetricsService {
  constructor(
    @InjectModel(PropertyEntity.name) private propertyModel: Model<PropertyDocument>,
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    @InjectModel(Contact.name) private contactModel: Model<ContactDocument>,
    @InjectModel(Role.name) private roleModel: Model<RoleDocument>,
    @InjectModel(Tenant.name) private tenantModel: Model<TenantDocument>,
  ) {}

  async getSystemMetrics() {
    try {
      // Get role IDs first
      const [regularUserRole, propertyOwnerRole, adminRole] = await Promise.all([
        this.roleModel.findOne({ name: 'regular_user' }),
        this.roleModel.findOne({ name: 'property_owner' }),
        this.roleModel.findOne({ name: 'admin' }),
      ]);

      const [
        totalProperties,
        publishedProperties,
        draftProperties,
        archivedProperties,
        disabledProperties,
        totalUsers,
        regularUsers,
        propertyOwners,
        admins,
        totalContacts,
        unreadContacts,
        recentProperties,
        topViewedProperties,
        recentContacts,
        totalTenants,
        activeTenants,
      ] = await Promise.all([
        // Property counts
        this.propertyModel.countDocuments({ deletedAt: null }),
        this.propertyModel.countDocuments({ 
          status: PropertyStatus.PUBLISHED, 
          deletedAt: null 
        }),
        this.propertyModel.countDocuments({ 
          status: PropertyStatus.DRAFT, 
          deletedAt: null 
        }),
        this.propertyModel.countDocuments({ 
          status: PropertyStatus.ARCHIVED, 
          deletedAt: null 
        }),
        this.propertyModel.countDocuments({ 
          status: PropertyStatus.DISABLED, 
          deletedAt: null 
        }),
        
        // User counts
        this.userModel.countDocuments({ deletedAt: null }),
        regularUserRole ? this.userModel.countDocuments({ 
          roles: { $in: [regularUserRole._id] },
          deletedAt: null 
        }) : 0,
        propertyOwnerRole ? this.userModel.countDocuments({ 
          roles: { $in: [propertyOwnerRole._id] },
          deletedAt: null 
        }) : 0,
        adminRole ? this.userModel.countDocuments({ 
          roles: { $in: [adminRole._id] },
          deletedAt: null 
        }) : 0,
        
        // Contact counts
        this.contactModel.countDocuments({ deletedAt: null }),
        this.contactModel.countDocuments({ 
          isRead: false,
          deletedAt: null 
        }),
        
        // Recent data
        this.propertyModel
          .find({ deletedAt: null })
          .sort({ createdAt: -1 })
          .limit(5)
          .populate('owner', 'name email')
          .populate('tenant', 'name slug')
          .exec(),
        
        this.propertyModel
          .find({ deletedAt: null })
          .sort({ views: -1 })
          .limit(5)
          .populate('owner', 'name email')
          .populate('tenant', 'name slug')
          .exec(),
        
        this.contactModel
          .find({ deletedAt: null })
          .sort({ createdAt: -1 })
          .limit(10)
          .populate('property', 'title')
          .populate('fromUser', 'name email')
          .populate('toUser', 'name email')
          .exec(),
        
        // Tenant counts
        this.tenantModel.countDocuments({ deletedAt: null }),
        this.tenantModel.countDocuments({ 
          isActive: true, 
          deletedAt: null 
        }),
      ]);

      return {
        summary: {
          tenants: {
            total: totalTenants,
            active: activeTenants,
          },
          properties: {
            total: totalProperties,
            published: publishedProperties,
            draft: draftProperties,
            archived: archivedProperties,
            disabled: disabledProperties,
          },
          users: {
            total: totalUsers,
            regular: regularUsers,
            owners: propertyOwners,
            admins: admins,
          },
          contacts: {
            total: totalContacts,
            unread: unreadContacts,
          },
        },
        recentActivity: {
          recentProperties: recentProperties.map(prop => ({
            id: prop._id,
            title: prop.title,
            status: prop.status,
            createdAt: prop.createdAt,
            owner: prop.owner,
            tenant: prop.tenant,
          })),
          topViewedProperties: topViewedProperties.map(prop => ({
            id: prop._id,
            title: prop.title,
            views: prop.views,
            favoritesCount: prop.favoritesCount,
          })),
          recentContacts: recentContacts.map(contact => ({
            id: contact._id,
            property: contact.property,
            fromUser: contact.fromUser,
            toUser: contact.toUser,
            message: contact.message?.substring(0, 100) + '...',
            createdAt: contact.createdAt,
          })),
        },
        updatedAt: new Date(),
      };
    } catch (error) {
      console.error('Error getting system metrics:', error);
      throw new BadRequestException('Failed to get system metrics');
    }
  }

  async getPropertyMetrics(timeRange: 'day' | 'week' | 'month' = 'week') {
    try {
      const now = new Date();
      let startDate = new Date();
      
      switch (timeRange) {
        case 'day':
          startDate.setDate(now.getDate() - 1);
          break;
        case 'week':
          startDate.setDate(now.getDate() - 7);
          break;
        case 'month':
          startDate.setMonth(now.getMonth() - 1);
          break;
      }

      const [
        propertiesCreated,
        propertiesPublished,
        propertiesViewedAgg,
        totalFavoritesAgg,
      ] = await Promise.all([
        this.propertyModel.countDocuments({
          createdAt: { $gte: startDate },
          deletedAt: null,
        }),
        this.propertyModel.countDocuments({
          publishedAt: { $gte: startDate },
          deletedAt: null,
        }),
        this.propertyModel.aggregate([
          {
            $match: {
              deletedAt: null,
              status: PropertyStatus.PUBLISHED,
            }
          },
          {
            $group: {
              _id: null,
              totalViews: { $sum: '$views' }
            }
          }
        ]),
        this.propertyModel.aggregate([
          {
            $match: {
              deletedAt: null,
              status: PropertyStatus.PUBLISHED,
            }
          },
          {
            $group: {
              _id: null,
              totalFavorites: { $sum: '$favoritesCount' }
            }
          }
        ]),
      ]);

      return {
        timeRange,
        period: { start: startDate, end: now },
        metrics: {
          propertiesCreated,
          propertiesPublished,
          totalViews: propertiesViewedAgg[0]?.totalViews || 0,
          totalFavorites: totalFavoritesAgg[0]?.totalFavorites || 0,
        },
      };
    } catch (error) {
      console.error('Error getting property metrics:', error);
      throw new BadRequestException('Failed to get property metrics');
    }
  }

  async getTenantMetrics(tenantId: string): Promise<any> {
  try {
    const tenantObjectId = new Types.ObjectId(tenantId);
    
    const [
      totalProperties,
      publishedProperties,
      draftProperties,
      archivedProperties,
      disabledProperties,
      totalUsers,
      totalContacts,
      recentProperties,
      topViewedProperties,
    ] = await Promise.all([
      // Property counts
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        deletedAt: null 
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.PUBLISHED, 
        deletedAt: null 
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.DRAFT, 
        deletedAt: null 
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.ARCHIVED, 
        deletedAt: null 
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.DISABLED, 
        deletedAt: null 
      }),
      
      // User count for this tenant
      this.userModel.countDocuments({ 
        tenant: tenantObjectId,
        deletedAt: null 
      }),
      
      // Contact count for this tenant's properties
      this.contactModel.countDocuments({ deletedAt: null }),
      
      // Recent data
      this.propertyModel
        .find({ 
          tenant: tenantObjectId,
          deletedAt: null 
        })
        .sort({ createdAt: -1 })
        .limit(5)
        .populate('owner', 'name email')
        .exec(),
      
      this.propertyModel
        .find({ 
          tenant: tenantObjectId,
          deletedAt: null,
          status: PropertyStatus.PUBLISHED 
        })
        .sort({ views: -1 })
        .limit(5)
        .populate('owner', 'name email')
        .exec(),
    ]);

    return {
      tenantId,
      summary: {
        properties: {
          total: totalProperties,
          published: publishedProperties,
          draft: draftProperties,
          archived: archivedProperties,
          disabled: disabledProperties,
        },
        users: {
          total: totalUsers,
        },
        contacts: {
          total: totalContacts,
        },
      },
      recentActivity: {
        recentProperties: recentProperties.map(prop => ({
          id: prop._id.toString(),
          title: prop.title,
          status: prop.status,
          views: prop.views,
          createdAt: prop.createdAt,
          owner: {
            id: (prop.owner as any)._id.toString(),
            name: (prop.owner as any).name,
          },
        })),
        topViewedProperties: topViewedProperties.map(prop => ({
          id: prop._id.toString(),
          title: prop.title,
          views: prop.views,
          favoritesCount: prop.favoritesCount,
          status: prop.status,
        })),
      },
      updatedAt: new Date(),
    };
  } catch (error) {
    console.error('Error getting tenant metrics:', error);
    throw new BadRequestException('Failed to get tenant metrics');
  }
}
}\n
===== ./properties/controllers/property.controller.ts =====
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
  BadRequestException,
  Request,
  UseInterceptors,
  UploadedFiles,
  NotFoundException,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth, ApiQuery } from '@nestjs/swagger';
import { PropertyCommands } from '../usecases/property/property.commands';
import { PropertyQueries } from '../usecases/property/property.queries';
import { PermissionsGuard } from '../../auth/guards/permissions.guard';
import { RequirePermissions } from '../../auth/decorators/permissions.decorator';
import { Permission } from '../../shared/constants/permissions';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { CreatePropertyDto } from '../dto/create-property.dto';
import { GetUser } from 'src/auth/decorators/get-user.decorator';
import { QueryPropertyDto } from '../dto/query-property.dto';
import { UpdatePropertyDto } from '../dto/update-property.dto';
import { FilesInterceptor } from '@nestjs/platform-express';
import { PropertyImagesService } from '../services/property-images.service';

@ApiTags('Properties')
@ApiBearerAuth()
@Controller('properties')
export class PropertyController {
  constructor(
    private readonly commands: PropertyCommands,
    private readonly queries: PropertyQueries,
     private readonly propertyImagesService: PropertyImagesService,
  ) {}

  @Post()
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_CREATE)
  @ApiOperation({ summary: 'Create a new property' })
  @ApiResponse({ status: 201, description: 'Property created successfully' })
  @ApiResponse({ status: 400, description: 'Bad request - validation failed' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden - insufficient permissions' })
  async create(
    @Body() createPropertyDto: CreatePropertyDto,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.create(createPropertyDto, user.userId, req.tenantId);
  }

  @Get()
  @ApiOperation({ summary: 'Get all properties with pagination and filtering' })
  @ApiQuery({ name: 'page', required: false, type: Number, example: 1 })
  @ApiQuery({ name: 'limit', required: false, type: Number, example: 10 })
  @ApiQuery({ name: 'status', required: false, enum: ['draft', 'published', 'archived', 'disabled'] })
  @ApiQuery({ name: 'city', required: false, type: String, example: 'New York' })
  @ApiQuery({ name: 'minPrice', required: false, type: Number, example: 1000 })
  @ApiQuery({ name: 'maxPrice', required: false, type: Number, example: 5000 })
  @ApiQuery({ name: 'type', required: false, enum: ['apartment', 'house', 'villa', 'commercial', 'land'] })
  @ApiQuery({ name: 'near', required: false, type: String, description: 'Coordinates: lng,lat (e.g., -73.935242,40.730610)' })
  @ApiQuery({ name: 'maxDistance', required: false, type: Number, description: 'Distance in meters (default: 5000)', example: 5000 })
  async findAll(
    @Query() query: QueryPropertyDto,
    @GetUser() user?: any,
    @Request() req?: any,
  ) {
    const userId = user?.userId;
    const permissions = user?.permissions || [];
    const tenantId = req?.tenantId;
    
    return this.queries.findAll(query, tenantId, userId, permissions);
  }

  @Get('my')
  @UseGuards(JwtAuthGuard)
  @ApiOperation({ summary: 'Get current user properties' })
  @ApiResponse({ status: 200, description: 'User properties retrieved' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async findMyProperties(
    @Query('status') status: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.queries.findByOwner(user.userId, req.tenantId, status);
  }

  @Get('favorites')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.FAVORITE_READ)
  @ApiOperation({ summary: 'Get user favorite properties' })
  @ApiResponse({ status: 200, description: 'Favorite properties retrieved' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async findFavorites(@GetUser() user: any, @Request() req: any) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.queries.findFavorites(user.userId, req.tenantId);
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get property by ID' })
  @ApiResponse({ status: 200, description: 'Property found' })
  @ApiResponse({ status: 404, description: 'Property not found' })
  async findOne(
    @Param('id') id: string,
    @GetUser() user?: any,
    @Request() req?: any,
  ) {
    const userId = user?.userId;
    const permissions = user?.permissions || [];
    const tenantId = req?.tenantId;
    
    await this.queries.incrementViews(id, tenantId);
    
    return this.queries.findById(id, tenantId, userId, permissions);
  }

  @Get(':id/validate')
  @UseGuards(JwtAuthGuard)
  @ApiOperation({ summary: 'Validate property for publishing' })
  @ApiResponse({ status: 200, description: 'Validation result' })
  @ApiResponse({ status: 404, description: 'Property not found' })
  async validateForPublishing(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.validateForPublishing(id, req.tenantId);
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_UPDATE_OWN, Permission.PROPERTY_UPDATE_ALL)
  @ApiOperation({ summary: 'Update property' })
  @ApiResponse({ status: 200, description: 'Property updated' })
  @ApiResponse({ status: 400, description: 'Cannot edit published property' })
  @ApiResponse({ status: 403, description: 'Forbidden - insufficient permissions' })
  async update(
    @Param('id') id: string,
    @Body() updatePropertyDto: UpdatePropertyDto,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.update(
      id,
      updatePropertyDto,
      user.userId,
      req.tenantId,
      user.permissions,
    );
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_DELETE_OWN, Permission.PROPERTY_DELETE_ALL)
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Soft delete property' })
  @ApiResponse({ status: 204, description: 'Property deleted' })
  @ApiResponse({ status: 403, description: 'Forbidden - insufficient permissions' })
  async remove(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    await this.commands.delete(id, user.userId, req.tenantId, user.permissions);
  }

  @Post(':id/publish')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_PUBLISH)
  @ApiOperation({ summary: 'Publish property' })
  @ApiResponse({ status: 200, description: 'Property published' })
  @ApiResponse({ status: 400, description: 'Validation failed' })
  async publish(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.publish(id, user.userId, req.tenantId);
  }

  @Post(':id/archive')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_ARCHIVE)
  @ApiOperation({ summary: 'Archive property' })
  @ApiResponse({ status: 200, description: 'Property archived' })
  async archive(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.archive(id, user.userId, req.tenantId);
  }

  @Post(':id/favorite')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.FAVORITE_CREATE)
  @ApiOperation({ summary: 'Add property to favorites' })
  @ApiResponse({ status: 200, description: 'Added to favorites' })
  async addFavorite(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.addToFavorites(id, user.userId, req.tenantId);
  }

  @Delete(':id/favorite')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.FAVORITE_DELETE)
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Remove property from favorites' })
  @ApiResponse({ status: 204, description: 'Removed from favorites' })
  async removeFavorite(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    await this.commands.removeFromFavorites(id, user.userId, req.tenantId);
  }

  @Post(':id/disable')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_UPDATE_ALL)
  @ApiOperation({ summary: 'Disable property (Admin only)' })
  @ApiResponse({ status: 200, description: 'Property disabled' })
  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
  async disable(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.disable(
      id,
      user.userId,
      req.tenantId,
      user.permissions,
    );
  }

  @Post(':id/enable')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_UPDATE_ALL)
  @ApiOperation({ summary: 'Enable property (Admin only)' })
  @ApiResponse({ status: 200, description: 'Property enabled' })
  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
  async enable(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    return this.commands.enable(
      id,
      user.userId,
      req.tenantId,
      user.permissions,
    );
  }

  @Get(':id/favorite/status')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.FAVORITE_READ)
  @ApiOperation({ summary: 'Check if property is favorited' })
  @ApiResponse({ status: 200, description: 'Favorite status retrieved' })
  async getFavoriteStatus(
    @Param('id') id: string,
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    const isFavorited = await this.queries.isFavorited(
      id,
      user.userId,
      req.tenantId,
    );
    return { isFavorited };
  }


 
  

    @Post(':id/images')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_UPDATE_OWN)
  @UseInterceptors(FilesInterceptor('images', 10))
  @ApiOperation({ summary: 'Upload images for a property' })
  @ApiResponse({ status: 200, description: 'Images uploaded successfully' })
  async uploadPropertyImages(
    @Param('id') id: string,
    @UploadedFiles() files: Express.Multer.File[],
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }

    const result = await this.propertyImagesService.uploadPropertyImages(
      id,
      files,
      user.userId,
      req.tenantId,
      user.permissions,
    );

    return { 
      success: true, 
      ...result,
      message: 'Images uploaded successfully'
    };
  }

  @Delete(':id/images')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.PROPERTY_UPDATE_OWN)
  @ApiOperation({ summary: 'Delete images from a property' })
  @ApiResponse({ status: 200, description: 'Images deleted successfully' })
  async deletePropertyImages(
    @Param('id') id: string,
    @Body() body: { urls: string[] },
    @GetUser() user: any,
    @Request() req: any,
  ) {
    if (!req.tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }

    if (!body.urls || !Array.isArray(body.urls) || body.urls.length === 0) {
      throw new BadRequestException('No image URLs provided');
    }

    await this.propertyImagesService.deletePropertyImages(
      id,
      body.urls,
      user.userId,
      req.tenantId,
      user.permissions,
    );

    return { 
      success: true, 
      message: 'Images deleted successfully',
      deletedCount: body.urls.length 
    };
  }
  

}\n
===== ./properties/domain/property/Property.repository.interface.ts =====
import { Property, PropertyStatus } from './Property';
import { QueryPropertyDto } from '../../dto/query-property.dto';

export interface IPropertyRepository {
  // Commands with tenant support
  create(property: Property, tenantId: string): Promise<Property>;
  update(id: string, property: Property, tenantId?: string): Promise<Property>;
  softDelete(id: string, tenantId?: string): Promise<void>;
  publish(id: string, tenantId?: string): Promise<Property>;
  archive(id: string, tenantId?: string): Promise<Property>;
  disable(id: string, disabledBy: string, tenantId?: string): Promise<Property>;
  enable(id: string, tenantId?: string): Promise<Property>;
  
  // Queries with tenant support
  findById(id: string, tenantId?: string): Promise<Property | null>;
  findByOwner(ownerId: string, tenantId?: string, status?: PropertyStatus): Promise<Property[]>;
  findAllPaginated(query: QueryPropertyDto, tenantId?: string): Promise<{
    data: Property[];
    total: number;
    page: number;
    limit: number;
  }>;
  findFavorites(userId: string, tenantId?: string): Promise<Property[]>;
  isFavorited(propertyId: string, userId: string, tenantId?: string): Promise<boolean>;
  addToFavorites(propertyId: string, userId: string, tenantId?: string): Promise<Property>;
  removeFromFavorites(propertyId: string, userId: string, tenantId?: string): Promise<Property>;
  
  // Additional methods
  incrementViews(id: string, tenantId?: string): Promise<void>;
  getTenantMetrics(tenantId: string): Promise<any>;
}\n
===== ./properties/domain/property/Property.ts =====
export enum PropertyStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
  DISABLED = 'disabled',
}

export enum PropertyType {
  APARTMENT = 'apartment',
  HOUSE = 'house',
  VILLA = 'villa',
  COMMERCIAL = 'commercial',
  LAND = 'land',
}

export interface PropertyValidationResult {
  isValid: boolean;
  errors: string[];
}

export class Property {
  id: string;
  title: string;
  description: string;
  location: {
    address: string;
    city: string;
    state?: string;
    country: string;
    coordinates?: {
      type: string;
      coordinates: [number, number];
    };
  };
  price: number;
  images: string[];
  status: PropertyStatus;
  type: PropertyType;
  ownerId: string;
  tenantId?: string;
  views: number = 0;
  favoritesCount: number = 0;
  favoritedBy: string[] = [];
  metadata?: Record<string, any>;
  publishedAt?: Date;
  deletedAt?: Date;
  disabledAt?: Date;
  disabledBy?: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(partial: Partial<Property> = {}) {
    Object.assign(this, partial);
    this.views = this.views || 0;
    this.favoritesCount = this.favoritesCount || 0;
    this.favoritedBy = this.favoritedBy || [];
  }

  validateForPublishing(): PropertyValidationResult {
    const errors: string[] = [];

    if (!this.title?.trim()) {
      errors.push('Title is required');
    }

    if (!this.description?.trim()) {
      errors.push('Description is required');
    }

    if (!this.location?.address?.trim() || !this.location?.city?.trim() || !this.location?.country?.trim()) {
      errors.push('Location must include address, city, and country');
    }

    if (this.price === undefined || this.price === null || this.price < 0) {
      errors.push('Valid price is required');
    }

    if (!this.images || this.images.length === 0) {
      errors.push('At least one image is required');
    } else if (this.images.length > 10) {
      errors.push('Maximum 10 images allowed');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  publish(): void {
    if (this.status === PropertyStatus.PUBLISHED) {
      throw new Error('Property is already published');
    }
    
    if (this.status === PropertyStatus.DISABLED) {
      throw new Error('Disabled properties cannot be published');
    }

    const validation = this.validateForPublishing();
    if (!validation.isValid) {
      throw new Error(`Cannot publish property: ${validation.errors.join(', ')}`);
    }

    this.status = PropertyStatus.PUBLISHED;
    this.publishedAt = new Date();
  }

  archive(): void {
    this.status = PropertyStatus.ARCHIVED;
  }

  disable(disabledBy: string): void {
    this.status = PropertyStatus.DISABLED;
    this.disabledAt = new Date();
    this.disabledBy = disabledBy;
  }

  enable(): void {
    if (this.status === PropertyStatus.DISABLED) {
      this.status = PropertyStatus.DRAFT;
      this.disabledAt = undefined;
      this.disabledBy = undefined;
    }
  }

  softDelete(): void {
    this.deletedAt = new Date();
  }

  isOwnedBy(userId: string): boolean {
    return this.ownerId === userId;
  }

  canBeEdited(): boolean {
    // Published properties cannot be edited per requirement
    return this.status !== PropertyStatus.PUBLISHED && this.status !== PropertyStatus.DISABLED;
  }

  canBePublished(): boolean {
    return this.status === PropertyStatus.DRAFT && 
           this.images && 
           this.images.length > 0;
  }

  addFavorite(userId: string): void {
    if (!this.favoritedBy.includes(userId)) {
      this.favoritedBy.push(userId);
      this.favoritesCount += 1;
    }
  }

  removeFavorite(userId: string): void {
    const index = this.favoritedBy.indexOf(userId);
    if (index > -1) {
      this.favoritedBy.splice(index, 1);
      this.favoritesCount = Math.max(0, this.favoritesCount - 1);
    }
  }

  belongsToTenant(tenantId?: string): boolean {
    if (!tenantId) return true; 
    return this.tenantId === tenantId;
  }
}\n
===== ./properties/dto/create-property.dto.ts =====
import { 
  IsString, 
  IsNumber, 
  IsEnum, 
  IsArray, 
  IsOptional, 
  Min, 
  MaxLength, 
  ArrayMaxSize,
  ValidateNested,
  IsObject,
  ArrayMinSize,
  ArrayNotEmpty 
} from 'class-validator';
import { Type } from 'class-transformer';
import { PropertyStatus, PropertyType } from '../domain/property/Property';

class CoordinatesDto {
  @IsString()
  @IsOptional()
  type?: string = 'Point';

  @IsArray()
  @ArrayMinSize(2)
  @ArrayMaxSize(2)
  @IsNumber({}, { each: true })
  coordinates: [number, number];
}

class LocationDto {
  @IsString()
  address: string;

  @IsString()
  city: string;

  @IsOptional()
  @IsString()
  state?: string;

  @IsString()
  country: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => CoordinatesDto)
  coordinates?: CoordinatesDto;
}

export class CreatePropertyDto {
  @IsString()
  @MaxLength(200)
  title: string;

  @IsString()
  @MaxLength(5000)
  description: string;

  @ValidateNested()
  @Type(() => LocationDto)
  location: LocationDto;

  @IsNumber()
  @Min(0)
  price: number;

  @IsOptional()
  @IsArray()
  @ArrayMaxSize(10)
  @ArrayNotEmpty()
  @IsString({ each: true })
  images?: string[];

  @IsEnum(PropertyType)
  type: PropertyType;

  @IsOptional()
  @IsEnum(PropertyStatus)
  status?: PropertyStatus = PropertyStatus.DRAFT;

  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}\n
===== ./properties/dto/metrics-property.dto.ts =====
import { IsOptional, IsEnum } from 'class-validator';
import { Type } from 'class-transformer';

export class MetricsPropertyDto {
  @IsOptional()
  @IsEnum(['day', 'week', 'month'])
  @Type(() => String)
  timeRange?: 'day' | 'week' | 'month' = 'week';
}\n
===== ./properties/dto/query-property.dto.ts =====
import { IsEnum, IsNumber, IsOptional, IsString, Min, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { PropertyStatus, PropertyType } from '../domain/property/Property';

export class QueryPropertyDto {
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number = 10;

  @IsOptional()
  @IsEnum(PropertyStatus)
  status?: PropertyStatus;

  @IsOptional()
  @IsString()
  city?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  minPrice?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  maxPrice?: number;

  @IsOptional()
  @IsEnum(PropertyType)
  type?: PropertyType;

  @IsOptional()
  @IsString()
  sortBy?: string = 'createdAt';

  @IsOptional()
  @IsString()
  sortOrder?: 'asc' | 'desc' = 'desc';

  @IsOptional()
  @IsString()
  near?: string; // Format: "lng,lat"

  @IsOptional()
  @Type(() => Number)
  @Min(100)
  maxDistance?: number = 5000; // Default 5km in meters
}\n
===== ./properties/dto/update-property.dto.ts =====
import { 
  IsString, 
  IsNumber, 
  IsEnum, 
  IsArray, 
  IsOptional, 
  Min, 
  MaxLength, 
  ArrayMaxSize,
  ValidateNested,
  IsObject,
  ArrayMinSize 
} from 'class-validator';
import { Type } from 'class-transformer';
import { PropertyStatus, PropertyType } from '../domain/property/Property';

class CoordinatesDto {
  @IsOptional()
  @IsString()
  type?: string = 'Point';

  @IsOptional()
  @IsArray()
  @ArrayMinSize(2)
  @ArrayMaxSize(2)
  @IsNumber({}, { each: true })
  coordinates?: [number, number];
}

class LocationDto {
  @IsOptional()
  @IsString()
  address?: string;

  @IsOptional()
  @IsString()
  city?: string;

  @IsOptional()
  @IsString()
  state?: string;

  @IsOptional()
  @IsString()
  country?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => CoordinatesDto)
  coordinates?: CoordinatesDto;
}

export class UpdatePropertyDto {
  @IsOptional()
  @IsString()
  @MaxLength(200)
  title?: string;

  @IsOptional()
  @IsString()
  @MaxLength(5000)
  description?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => LocationDto)
  location?: LocationDto;

  @IsOptional()
  @IsNumber()
  @Min(0)
  price?: number;

  @IsOptional()
  @IsArray()
  @ArrayMaxSize(10)
  @IsString({ each: true })
  images?: string[];

  @IsOptional()
  @IsEnum(PropertyType)
  type?: PropertyType;

  @IsOptional()
  @IsEnum(PropertyStatus)
  status?: PropertyStatus;

  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}\n
===== ./properties/persistence/property/property.entity.ts =====

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { PropertyStatus, PropertyType } from '../../domain/property/Property';

export type PropertyDocument = PropertyEntity & Document;

interface PropertyTransformed {
  [key: string]: any;
  __v?: number;
}

@Schema({
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: (_, ret: PropertyTransformed) => {
      const { __v, ...rest } = ret;
      return rest;
    },
  },
})
export class PropertyEntity extends Document {
  @Prop({ required: true, trim: true, index: true })
  title: string;

  @Prop({ required: true })
  description: string;

  @Prop({
    type: {
      address: { type: String, required: true },
      city: { type: String, required: true, index: true },
      state: String,
      country: { type: String, required: true },
      coordinates: {
        type: { type: String, enum: ['Point'], default: 'Point' },
        coordinates: { type: [Number], default: [0, 0] },
      },
    },
    required: true,
  })
  location: {
    address: string;
    city: string;
    state?: string;
    country: string;
    coordinates?: {
      type: string;
      coordinates: [number, number];
    };
  };

  @Prop({ required: true, min: 0, index: true })
  price: number;

  @Prop({ type: [String], default: [] })
  images: string[];

  @Prop({ 
    type: String, 
    enum: PropertyStatus, 
    default: PropertyStatus.DRAFT,
    index: true 
  })
  status: PropertyStatus;

  @Prop({ 
    type: String, 
    enum: PropertyType, 
    required: true 
  })
  type: PropertyType;

  @Prop({ 
    type: Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true 
  })
  owner: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Tenant', required: true, index: true })
  tenant: Types.ObjectId;

  @Prop({ default: 0 })
  views: number;

  @Prop({ default: 0 })
  favoritesCount: number;

  @Prop({ type: [Types.ObjectId], ref: 'User', default: [] })
  favoritedBy: Types.ObjectId[];

  @Prop({ type: Object })
  metadata?: Record<string, any>;

  @Prop()
  publishedAt?: Date;

  @Prop()
  disabledAt?: Date;

  @Prop({ type: Types.ObjectId, ref: 'User' })
  disabledBy?: Types.ObjectId;

  @Prop()
  deletedAt?: Date;

  @Prop({ default: true })
  isActive: boolean;

  createdAt: Date;
  updatedAt: Date;
}

export const PropertySchema = SchemaFactory.createForClass(PropertyEntity);

// Compound indexes
PropertySchema.index({ tenant: 1, status: 1 });
PropertySchema.index({ tenant: 1, owner: 1, status: 1 });
PropertySchema.index({ tenant: 1, 'location.city': 1, status: 1 });
PropertySchema.index({ tenant: 1, price: 1, status: 1 });
PropertySchema.index({ 'location.coordinates': '2dsphere' });

// Pre-find hooks for soft delete and tenant filtering
PropertySchema.pre('find', function() {
  const tenantId = this.getOptions().tenantId;
  if (tenantId) {
    this.where({ tenant: tenantId, deletedAt: null });
  } else {
    this.where({ deletedAt: null });
  }
});

PropertySchema.pre('findOne', function() {
  const tenantId = this.getOptions().tenantId;
  if (tenantId) {
    this.where({ tenant: tenantId, deletedAt: null });
  } else {
    this.where({ deletedAt: null });
  }
});

PropertySchema.pre('countDocuments', function() {
  const tenantId = this.getOptions().tenantId;
  if (tenantId) {
    this.where({ tenant: tenantId, deletedAt: null });
  } else {
    this.where({ deletedAt: null });
  }
});

PropertySchema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.__v;
  return obj;
};\n
===== ./properties/persistence/property/property.repository.ts =====
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { PropertyEntity, PropertyDocument } from './property.entity';
import { Property, PropertyStatus } from '../../domain/property/Property';
import { IPropertyRepository } from '../../domain/property/Property.repository.interface';
import { QueryPropertyDto } from '../../dto/query-property.dto';

@Injectable()
export class PropertyRepository implements IPropertyRepository {
  constructor(
    @InjectModel(PropertyEntity.name)
    private readonly propertyModel: Model<PropertyDocument>,
  ) {}

  private buildTenantQuery(tenantId?: string, baseQuery: any = {}): any {
    const query = { ...baseQuery, deletedAt: null };
    
    if (tenantId) {
      query.tenant = new Types.ObjectId(tenantId);
    }
    
    return query;
  }

  async create(property: Property, tenantId: string): Promise<Property> {
    const entity = this.toEntity(property);
    entity.tenant = new Types.ObjectId(tenantId);
    const saved = await this.propertyModel.create(entity);
    return this.toDomain(saved);
  }

  async update(id: string, property: Property, tenantId?: string): Promise<Property> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });
    
    const entity = this.toEntity(property);
    const updated = await this.propertyModel
      .findOneAndUpdate(query, entity, { new: true })
      .populate('owner', 'name email')
      .populate('disabledBy', 'name email')
      .exec();
    
    if (!updated) {
      throw new NotFoundException(`Property with id ${id} not found`);
    }
    
    return this.toDomain(updated);
  }

  async softDelete(id: string, tenantId?: string): Promise<void> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });

    const result = await this.propertyModel.findOneAndUpdate(
      query,
      { deletedAt: new Date() },
      { new: true },
    ).exec();
    
    if (!result) {
      throw new NotFoundException(`Property with id ${id} not found`);
    }
  }

  async publish(id: string, tenantId?: string): Promise<Property> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });

    const session = await this.propertyModel.db.startSession();
    session.startTransaction();

    try {
      const property = await this.propertyModel
        .findOne(query)
        .session(session);

      if (!property) {
        throw new NotFoundException(`Property with id ${id} not found`);
      }

      // Convert to domain for validation
      const domainProperty = this.toDomain(property);
      
      // Validate and publish
      domainProperty.publish();
      
      // Update entity
      property.status = domainProperty.status;
      property.publishedAt = domainProperty.publishedAt;
      
      await property.save({ session });
      await session.commitTransaction();

      return domainProperty;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async archive(id: string, tenantId?: string): Promise<Property> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });

    const updated = await this.propertyModel
      .findOneAndUpdate(
        query,
        { status: PropertyStatus.ARCHIVED },
        { new: true },
      )
      .populate('owner', 'name email')
      .exec();
    
    if (!updated) {
      throw new NotFoundException(`Property with id ${id} not found`);
    }
    
    return this.toDomain(updated);
  }

  async disable(id: string, disabledBy: string, tenantId?: string): Promise<Property> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });

    const updated = await this.propertyModel
      .findOneAndUpdate(
        query,
        { 
          status: PropertyStatus.DISABLED,
          disabledAt: new Date(),
          disabledBy: new Types.ObjectId(disabledBy),
        },
        { new: true },
      )
      .populate('owner', 'name email')
      .populate('disabledBy', 'name email')
      .exec();
    
    if (!updated) {
      throw new NotFoundException(`Property with id ${id} not found`);
    }
    
    return this.toDomain(updated);
  }

  async enable(id: string, tenantId?: string): Promise<Property> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });

    const updated = await this.propertyModel
      .findOneAndUpdate(
        query,
        { 
          status: PropertyStatus.DRAFT,
          disabledAt: null,
          disabledBy: null,
        },
        { new: true },
      )
      .populate('owner', 'name email')
      .exec();
    
    if (!updated) {
      throw new NotFoundException(`Property with id ${id} not found`);
    }
    
    return this.toDomain(updated);
  }

  async findById(id: string, tenantId?: string): Promise<Property | null> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });

    const entity = await this.propertyModel
      .findOne(query)
      .populate('owner', 'name email')
      .populate('tenant', 'name slug')
      .populate('disabledBy', 'name email')
      .exec();
    
    return entity ? this.toDomain(entity) : null;
  }

  async findByOwner(ownerId: string, tenantId?: string, status?: PropertyStatus): Promise<Property[]> {
    const query = this.buildTenantQuery(tenantId, { owner: new Types.ObjectId(ownerId) });
    
    if (status) {
      query.status = status;
    }

    const entities = await this.propertyModel
      .find(query)
      .sort({ createdAt: -1 })
      .populate('owner', 'name email')
      .populate('tenant', 'name slug')
      .exec();
    
    return entities.map(entity => this.toDomain(entity));
  }


  async findAllPaginated(query: QueryPropertyDto, tenantId?: string): Promise<{
  data: Property[];
  total: number;
  page: number;
  limit: number;
}> {
  const filter = this.buildTenantQuery(tenantId);
  
  if (query.status) {
    filter.status = query.status;
  }
  
  if (query.city) {
    filter['location.city'] = new RegExp(query.city, 'i');
  }
  
  if (query.type) {
    filter.type = query.type;
  }
  
  if (query.minPrice || query.maxPrice) {
    filter.price = {};
    if (query.minPrice !== undefined) {
      filter.price.$gte = Number(query.minPrice);
    }
    if (query.maxPrice !== undefined) {
      filter.price.$lte = Number(query.maxPrice);
    }
  }

  // Add geospatial query if near coordinates provided
  if (query.near && query.maxDistance) {
    try {
      const [lngStr, latStr] = query.near.split(',');
      const lng = parseFloat(lngStr);
      const lat = parseFloat(latStr);
      
      if (!isNaN(lng) && !isNaN(lat)) {
        filter['location.coordinates'] = {
          $near: {
            $geometry: {
              type: 'Point',
              coordinates: [lng, lat]
            },
            $maxDistance: query.maxDistance
          }
        };
      }
    } catch (error) {
      console.warn('Invalid geospatial query:', error);
    }
  }

  const page = query.page ?? 1;
  const limit = query.limit ?? 10;
  const skip = (page - 1) * limit;
  const sortBy = query.sortBy ?? 'createdAt';
  const sortOrder = query.sortOrder === 'asc' ? 1 : -1;
  
  const sort: Record<string, 1 | -1> = { [sortBy]: sortOrder as 1 | -1 };

  const [entities, total] = await Promise.all([
    this.propertyModel
      .find(filter)
      .populate('owner', 'name email')
      .populate('tenant', 'name slug')
      .sort(sort)
      .skip(skip)
      .limit(limit)
      .exec(),
    this.propertyModel.countDocuments(filter).exec(),
  ]);

  return {
    data: entities.map(entity => this.toDomain(entity)),
    total,
    page,
    limit,
  };
}


  async findFavorites(userId: string, tenantId?: string): Promise<Property[]> {
    const query = this.buildTenantQuery(tenantId, {
      favoritedBy: new Types.ObjectId(userId),
      status: PropertyStatus.PUBLISHED,
    });

    const entities = await this.propertyModel
      .find(query)
      .populate('owner', 'name email')
      .populate('tenant', 'name slug')
      .exec();
    
    return entities.map(entity => this.toDomain(entity));
  }

  async isFavorited(propertyId: string, userId: string, tenantId?: string): Promise<boolean> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(propertyId) });

    const property = await this.propertyModel.findOne(query);
    if (!property) {
      return false;
    }

    return property.favoritedBy.some(id => 
      id.equals(new Types.ObjectId(userId))
    );
  }

  async addToFavorites(propertyId: string, userId: string, tenantId?: string): Promise<Property> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(propertyId) });

    const property = await this.propertyModel.findOne(query);
    
    if (!property) {
      throw new NotFoundException(`Property with id ${propertyId} not found`);
    }

    const userObjectId = new Types.ObjectId(userId);
    
    if (!property.favoritedBy.some(id => id.equals(userObjectId))) {
      property.favoritedBy.push(userObjectId);
      property.favoritesCount += 1;
      await property.save();
    }

    return this.toDomain(property);
  }

  async removeFromFavorites(propertyId: string, userId: string, tenantId?: string): Promise<Property> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(propertyId) });

    const property = await this.propertyModel.findOne(query);
    
    if (!property) {
      throw new NotFoundException(`Property with id ${propertyId} not found`);
    }

    const userObjectId = new Types.ObjectId(userId);
    const initialLength = property.favoritedBy.length;

    property.favoritedBy = property.favoritedBy.filter(
      id => !id.equals(userObjectId),
    );

    if (property.favoritedBy.length < initialLength) {
      property.favoritesCount = Math.max(0, property.favoritesCount - 1);
      await property.save();
    }

    return this.toDomain(property);
  }

  async incrementViews(id: string, tenantId?: string): Promise<void> {
    const query = this.buildTenantQuery(tenantId, { _id: new Types.ObjectId(id) });

    await this.propertyModel.findOneAndUpdate(
      query,
      { $inc: { views: 1 } },
      { new: true },
    ).exec();
  }

  async getTenantMetrics(tenantId: string): Promise<any> {
    const tenantObjectId = new Types.ObjectId(tenantId);
    
    const [
      totalProperties,
      publishedProperties,
      draftProperties,
      archivedProperties,
      disabledProperties,
      totalViews,
      totalFavorites,
      recentProperties,
      topViewedProperties,
    ] = await Promise.all([
      // Counts
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        deletedAt: null,
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.PUBLISHED,
        deletedAt: null,
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.DRAFT,
        deletedAt: null,
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.ARCHIVED,
        deletedAt: null,
      }),
      this.propertyModel.countDocuments({ 
        tenant: tenantObjectId,
        status: PropertyStatus.DISABLED,
        deletedAt: null,
      }),
      
      // Aggregates
      this.propertyModel.aggregate([
        {
          $match: {
            tenant: tenantObjectId,
            deletedAt: null,
          }
        },
        {
          $group: {
            _id: null,
            totalViews: { $sum: '$views' }
          }
        }
      ]),
      
      this.propertyModel.aggregate([
        {
          $match: {
            tenant: tenantObjectId,
            deletedAt: null,
          }
        },
        {
          $group: {
            _id: null,
            totalFavorites: { $sum: '$favoritesCount' }
          }
        }
      ]),
      
      // Recent data
      this.propertyModel
        .find({
          tenant: tenantObjectId,
          deletedAt: null,
        })
        .sort({ createdAt: -1 })
        .limit(5)
        .populate('owner', 'name email')
        .exec(),
      
      this.propertyModel
        .find({
          tenant: tenantObjectId,
          deletedAt: null,
          status: PropertyStatus.PUBLISHED,
        })
        .sort({ views: -1 })
        .limit(5)
        .populate('owner', 'name email')
        .exec(),
    ]);

    return {
      tenantId,
      summary: {
        properties: {
          total: totalProperties,
          published: publishedProperties,
          draft: draftProperties,
          archived: archivedProperties,
          disabled: disabledProperties,
        },
        engagement: {
          totalViews: totalViews[0]?.totalViews || 0,
          totalFavorites: totalFavorites[0]?.totalFavorites || 0,
        },
      },
      recentActivity: {
        recentProperties: recentProperties.map(prop => ({
          id: prop._id.toString(),
          title: prop.title,
          status: prop.status,
          views: prop.views,
          createdAt: prop.createdAt,
          owner: {
            id: (prop.owner as any)._id.toString(),
            name: (prop.owner as any).name,
          },
        })),
        topViewedProperties: topViewedProperties.map(prop => ({
          id: prop._id.toString(),
          title: prop.title,
          views: prop.views,
          favoritesCount: prop.favoritesCount,
          status: prop.status,
        })),
      },
      updatedAt: new Date(),
    };
  }

  private toDomain(entity: PropertyEntity): Property {
    const property = new Property();
    property.id = entity._id.toString();
    property.title = entity.title;
    property.description = entity.description;
    
    property.location = {
      address: entity.location.address || '',
      city: entity.location.city || '',
      country: entity.location.country || '',
      state: entity.location.state,
    };
    
    if (entity.location.coordinates) {
      property.location.coordinates = {
        type: entity.location.coordinates.type || 'Point',
        coordinates: entity.location.coordinates.coordinates || [0, 0],
      };
    }
    
    property.price = entity.price || 0;
    property.images = entity.images || [];
    property.status = entity.status || PropertyStatus.DRAFT;
    property.type = entity.type;
    property.ownerId = entity.owner.toString();
    property.tenantId = entity.tenant?.toString();
    property.views = entity.views || 0;
    property.favoritesCount = entity.favoritesCount || 0;
    property.favoritedBy = entity.favoritedBy.map(id => id.toString());
    property.metadata = entity.metadata;
    property.publishedAt = entity.publishedAt;
    property.deletedAt = entity.deletedAt;
    property.disabledAt = entity.disabledAt;
    property.disabledBy = entity.disabledBy?.toString();
    property.createdAt = entity.createdAt;
    property.updatedAt = entity.updatedAt;
    
    return property;
  }

  private toEntity(property: Property): Partial<PropertyEntity> {
    const location: any = {
      address: property.location.address,
      city: property.location.city,
      country: property.location.country,
      state: property.location.state,
    };
    
    if (property.location.coordinates) {
      location.coordinates = {
        type: property.location.coordinates.type || 'Point',
        coordinates: property.location.coordinates.coordinates,
      };
    }
    
    const entity: Partial<PropertyEntity> = {
      title: property.title,
      description: property.description,
      location,
      price: property.price,
      images: property.images,
      status: property.status,
      type: property.type,
      owner: new Types.ObjectId(property.ownerId),
      views: property.views,
      favoritesCount: property.favoritesCount,
      favoritedBy: property.favoritedBy.map(id => new Types.ObjectId(id)),
      metadata: property.metadata,
      publishedAt: property.publishedAt,
      deletedAt: property.deletedAt,
      disabledAt: property.disabledAt,
    };
    
    if (property.disabledBy) {
      entity.disabledBy = new Types.ObjectId(property.disabledBy);
    }
    
    if (property.tenantId) {
      entity.tenant = new Types.ObjectId(property.tenantId);
    }
    
    return entity;
  }
}\n
===== ./properties/properties.module.ts =====
// ./properties/properties.module.ts
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PropertyController } from './controllers/property.controller';
import { PropertyCommands } from './usecases/property/property.commands';
import { PropertyQueries } from './usecases/property/property.queries';
import { PropertyRepository } from './persistence/property/property.repository';
import { PropertyEntity, PropertySchema } from './persistence/property/property.entity';
import { LoggerModule } from '../shared/infrastructure/logger/logger.module';
import { MetricsModule } from '../metrics/metrics.module';
import { User, UserSchema } from '../users/schemas/user.schema';
import { ImagesModule } from '../images/images.module';
import { PropertyImagesService } from './services/property-images.service'; 

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: PropertyEntity.name, schema: PropertySchema },
      { name: User.name, schema: UserSchema },
    ]),
    ImagesModule,
    LoggerModule,
    MetricsModule,
  ],
  controllers: [PropertyController],
  providers: [
    PropertyCommands, 
    PropertyQueries, 
    PropertyRepository,
    PropertyImagesService, 
  ],
  exports: [
    PropertyCommands, 
    PropertyQueries, 
    PropertyRepository,
    PropertyImagesService, 
    MongooseModule,
  ],
})
export class PropertiesModule {}\n
===== ./properties/services/property-images.service.ts =====
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { ImagesService } from '../../images/images.service';
import { PropertyRepository } from '../persistence/property/property.repository';
import { Permission } from '../../shared/constants/permissions';

@Injectable()
export class PropertyImagesService {
  constructor(
    private readonly imagesService: ImagesService,
    private readonly propertyRepository: PropertyRepository,
  ) {}

  async uploadPropertyImages(
    propertyId: string,
    files: Express.Multer.File[],
    userId: string,
    tenantId: string,
    userPermissions: string[] = [],
  ): Promise<{ urls: string[]; propertyId: string }> {
    if (!files || files.length === 0) {
      throw new BadRequestException('No files uploaded');
    }

    // Check property exists and user has permission
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    if (!property) {
      throw new NotFoundException('Property not found');
    }

    // Permission check
    const canUpdateAll = userPermissions.includes(Permission.PROPERTY_UPDATE_ALL);
    const canUpdateOwn = userPermissions.includes(Permission.PROPERTY_UPDATE_OWN);
    
    if (!canUpdateAll && (!canUpdateOwn || !property.isOwnedBy(userId))) {
      throw new BadRequestException('Insufficient permissions to update property');
    }

    // Check if property can be edited
    if (!property.canBeEdited()) {
      throw new BadRequestException('Published or disabled properties cannot be edited');
    }

    // Upload images
    const folder = `property-listings/tenant-${tenantId}/user-${userId}/property-${propertyId}`;
    const urls = await this.imagesService.uploadMultipleImages(files, folder);

    // Update property with new images
    property.images = [...(property.images || []), ...urls];
    await this.propertyRepository.update(propertyId, property, tenantId);

    return { urls, propertyId };
  }

  async deletePropertyImages(
    propertyId: string,
    imageUrls: string[],
    userId: string,
    tenantId: string,
    userPermissions: string[] = [],
  ): Promise<void> {
    // Check property exists and user has permission
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    if (!property) {
      throw new NotFoundException('Property not found');
    }

    // Permission check
    const canUpdateAll = userPermissions.includes(Permission.PROPERTY_UPDATE_ALL);
    const canUpdateOwn = userPermissions.includes(Permission.PROPERTY_UPDATE_OWN);
    
    if (!canUpdateAll && (!canUpdateOwn || !property.isOwnedBy(userId))) {
      throw new BadRequestException('Insufficient permissions to update property');
    }

    // Filter out the images to delete
    property.images = property.images.filter(img => !imageUrls.includes(img));
    await this.propertyRepository.update(propertyId, property, tenantId);

    // Delete from cloud storage
    await this.imagesService.deleteMultipleImages(imageUrls);
  }
}\n
===== ./properties/usecases/property/property.commands.ts =====
import { Injectable, BadRequestException, Inject, forwardRef } from '@nestjs/common';
import { Property, PropertyStatus } from '../../domain/property/Property';
import { CreatePropertyDto } from '../../dto/create-property.dto';
import { UpdatePropertyDto } from '../../dto/update-property.dto';
import { PropertyRepository } from '../../persistence/property/property.repository';
import { PropertyResponse } from './property.response';
import { LoggerService } from '../../../shared/infrastructure/logger/logger.service';
import { Permission } from '../../../shared/constants/permissions';

@Injectable()
export class PropertyCommands {
  constructor(
    private readonly propertyRepository: PropertyRepository,
    private readonly logger: LoggerService,
  ) {}

  async create(command: CreatePropertyDto, userId: string, tenantId: string): Promise<PropertyResponse> {
    this.logger.log('PropertyCommands', `Creating property for user ${userId} in tenant ${tenantId}`);
    
    const property = new Property();
    property.title = command.title;
    property.description = command.description;
    
    property.location = {
      address: command.location.address,
      city: command.location.city,
      country: command.location.country,
      state: command.location.state,
    };
    
    if (command.location.coordinates) {
      property.location.coordinates = {
        type: command.location.coordinates.type || 'Point',
        coordinates: command.location.coordinates.coordinates,
      };
    }
    
    property.price = command.price;
    property.images = command.images || [];
    property.type = command.type;
    property.status = command.status || PropertyStatus.DRAFT;
    property.ownerId = userId;
    property.tenantId = tenantId;
    property.metadata = command.metadata;

    const created = await this.propertyRepository.create(property, tenantId);
    
    this.logger.log('PropertyCommands', `Property ${created.id} created successfully`);
    return PropertyResponse.fromDomain(created);
  }

  async update(
    propertyId: string, 
    command: UpdatePropertyDto, 
    userId: string,
    tenantId: string,
    userPermissions: string[],
  ): Promise<PropertyResponse> {
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    // Business rule: Published properties cannot be edited (for anyone including admins)
    if (property.status === PropertyStatus.PUBLISHED) {
      throw new BadRequestException('Published properties cannot be edited');
    }

    // Permission check
    const canUpdateAll = userPermissions.includes(Permission.PROPERTY_UPDATE_ALL);
    const canUpdateOwn = userPermissions.includes(Permission.PROPERTY_UPDATE_OWN);
    
    if (!canUpdateAll && (!canUpdateOwn || !property.isOwnedBy(userId))) {
      throw new BadRequestException('Insufficient permissions to update property');
    }

    // Update allowed fields
    if (command.title !== undefined) property.title = command.title;
    if (command.description !== undefined) property.description = command.description;
    
    if (command.location !== undefined) {
      property.location = {
        address: command.location.address || property.location.address,
        city: command.location.city || property.location.city,
        country: command.location.country || property.location.country,
        state: command.location.state ?? property.location.state,
      };
      
      if (command.location.coordinates) {
        property.location.coordinates = {
          type: command.location.coordinates.type || 'Point',
          coordinates: command.location.coordinates.coordinates || [0, 0],
        };
      } else if (command.location.coordinates === null) {
        delete property.location.coordinates;
      }
    }
    
    if (command.price !== undefined) property.price = command.price;
    if (command.images !== undefined) property.images = command.images;
    if (command.type !== undefined) property.type = command.type;
    if (command.metadata !== undefined) property.metadata = command.metadata;

    const updated = await this.propertyRepository.update(propertyId, property, tenantId);
    
    this.logger.log('PropertyCommands', `Property ${propertyId} updated by user ${userId}`);
    return PropertyResponse.fromDomain(updated);
  }

  async publish(propertyId: string, userId: string, tenantId: string): Promise<PropertyResponse> {
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    if (!property.isOwnedBy(userId)) {
      throw new BadRequestException('Only property owners can publish properties');
    }

    const published = await this.propertyRepository.publish(propertyId, tenantId);
    return PropertyResponse.fromDomain(published);
  }

  async archive(propertyId: string, userId: string, tenantId: string): Promise<PropertyResponse> {
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    if (!property.isOwnedBy(userId)) {
      throw new BadRequestException('Only property owners can archive properties');
    }

    const archived = await this.propertyRepository.archive(propertyId, tenantId);
    return PropertyResponse.fromDomain(archived);
  }

  async delete(
    propertyId: string, 
    userId: string,
    tenantId: string,
    userPermissions: string[],
  ): Promise<void> {
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    const canDeleteAll = userPermissions.includes(Permission.PROPERTY_DELETE_ALL);
    const canDeleteOwn = userPermissions.includes(Permission.PROPERTY_DELETE_OWN);
    
    if (!canDeleteAll && (!canDeleteOwn || !property.isOwnedBy(userId))) {
      throw new BadRequestException('Insufficient permissions to delete property');
    }

    await this.propertyRepository.softDelete(propertyId, tenantId);
    
    this.logger.log('PropertyCommands', `Property ${propertyId} soft-deleted by user ${userId}`);
  }

  async disable(
    propertyId: string, 
    userId: string,
    tenantId: string,
    userPermissions: string[],
  ): Promise<PropertyResponse> {
    if (!userPermissions.includes(Permission.PROPERTY_UPDATE_ALL)) {
      throw new BadRequestException('Only admins can disable properties');
    }

    const property = await this.propertyRepository.findById(propertyId, tenantId);
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    const disabled = await this.propertyRepository.disable(propertyId, userId, tenantId);
    return PropertyResponse.fromDomain(disabled);
  }

  async enable(
    propertyId: string, 
    userId: string,
    tenantId: string,
    userPermissions: string[],
  ): Promise<PropertyResponse> {
    if (!userPermissions.includes(Permission.PROPERTY_UPDATE_ALL)) {
      throw new BadRequestException('Only admins can enable properties');
    }

    const property = await this.propertyRepository.findById(propertyId, tenantId);
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    const enabled = await this.propertyRepository.enable(propertyId, tenantId);
    return PropertyResponse.fromDomain(enabled);
  }

  async validateForPublishing(propertyId: string, tenantId: string): Promise<any> {
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    const validation = property.validateForPublishing();
    
    return {
      propertyId,
      isValid: validation.isValid,
      errors: validation.errors,
      canBePublished: property.status === PropertyStatus.DRAFT && validation.isValid,
      property: {
        title: property.title,
        status: property.status,
        hasImages: property.images?.length > 0,
        imageCount: property.images?.length || 0,
      }
    };
  }


  async addToFavorites(propertyId: string, userId: string, tenantId: string): Promise<PropertyResponse> {
  this.logger.log('PropertyCommands', `Adding property ${propertyId} to favorites for user ${userId}`);
  
  const property = await this.propertyRepository.addToFavorites(propertyId, userId, tenantId);
  return PropertyResponse.fromDomain(property);
}

async removeFromFavorites(propertyId: string, userId: string, tenantId: string): Promise<PropertyResponse> {
  this.logger.log('PropertyCommands', `Removing property ${propertyId} from favorites for user ${userId}`);
  
  const property = await this.propertyRepository.removeFromFavorites(propertyId, userId, tenantId);
  return PropertyResponse.fromDomain(property);
}

}\n
===== ./properties/usecases/property/property.queries.ts =====
import { Injectable, BadRequestException, Inject } from '@nestjs/common';
import { Property, PropertyStatus } from '../../domain/property/Property';
import { QueryPropertyDto } from '../../dto/query-property.dto';
import { PropertyRepository } from '../../persistence/property/property.repository';
import { Permission } from '../../../shared/constants/permissions';
import { PropertyResponse } from './property.response';
import { MetricsService } from '../../../metrics/metrics.service';

@Injectable()
export class PropertyQueries {
  constructor(
    private readonly propertyRepository: PropertyRepository,
    @Inject(MetricsService) private readonly metricsService: MetricsService,
  ) {}

  async findAll(
    query: QueryPropertyDto,
    tenantId?: string,
    userId?: string,
    userPermissions: string[] = [],
  ): Promise<{
    data: PropertyResponse[];
    total: number;
    page: number;
    limit: number;
  }> {
    // If user doesn't have permission to read all properties, only show published
    if (!userPermissions.includes(Permission.PROPERTY_READ_ALL)) {
      query.status = PropertyStatus.PUBLISHED;
    }

    const result = await this.propertyRepository.findAllPaginated(query, tenantId);
    
    return {
      data: result.data.map(property => PropertyResponse.fromDomain(property, userId)),
      total: result.total,
      page: result.page,
      limit: result.limit,
    };
  }

  async findById(
    propertyId: string,
    tenantId?: string,
    userId?: string,
    userPermissions: string[] = [],
  ): Promise<PropertyResponse> {
    const property = await this.propertyRepository.findById(propertyId, tenantId);
    
    if (!property) {
      throw new BadRequestException('Property not found');
    }

    // Permission checks
    const canReadAll = userPermissions.includes(Permission.PROPERTY_READ_ALL);
    const canReadOwn = userPermissions.includes(Permission.PROPERTY_READ_OWN);
    
    const isPublished = property.status === PropertyStatus.PUBLISHED;
    const isDisabled = property.status === PropertyStatus.DISABLED;
    
    if (isDisabled && !canReadAll) {
      throw new BadRequestException('Property is disabled');
    }
    
    // Handle undefined userId safely
    const isOwnedByUser = userId ? property.isOwnedBy(userId) : false;
    
    if (!isPublished && !canReadAll && (!canReadOwn || !isOwnedByUser)) {
      throw new BadRequestException('Insufficient permissions to view this property');
    }

    return PropertyResponse.fromDomain(property, userId);
  }

  async findByOwner(
    ownerId: string,
    tenantId: string,
    status?: string,
  ): Promise<PropertyResponse[]> {
    const propertyStatus = status ? (status as PropertyStatus) : undefined;
    const properties = await this.propertyRepository.findByOwner(ownerId, tenantId, propertyStatus);
    return properties.map(property => PropertyResponse.fromDomain(property, ownerId));
  }

  async findFavorites(userId: string, tenantId: string): Promise<PropertyResponse[]> {
    const properties = await this.propertyRepository.findFavorites(userId, tenantId);
    return properties.map(property => PropertyResponse.fromDomain(property, userId));
  }

  async isFavorited(propertyId: string, userId: string, tenantId: string): Promise<boolean> {
    return await this.propertyRepository.isFavorited(propertyId, userId, tenantId);
  }

  async incrementViews(id: string, tenantId?: string): Promise<void> {
    await this.propertyRepository.incrementViews(id, tenantId);
  }

  async getMetrics(userPermissions: string[]): Promise<any> {
    if (!userPermissions.includes(Permission.SYSTEM_METRICS_READ)) {
      throw new BadRequestException('Insufficient permissions to view system metrics');
    }

    return this.metricsService.getSystemMetrics();
  }

  async getPropertyMetrics(timeRange: 'day' | 'week' | 'month' = 'week'): Promise<any> {
    return this.metricsService.getPropertyMetrics(timeRange);
  }

  async getTenantMetrics(tenantId: string): Promise<any> {
    return this.propertyRepository.getTenantMetrics(tenantId);
  }
}\n
===== ./properties/usecases/property/property.response.ts =====
import { Property, PropertyStatus, PropertyType } from '../../domain/property/Property';
import { PropertyEntity } from '../../persistence/property/property.entity';
import { Types } from 'mongoose';

export class PropertyResponse {
  id: string;
  title: string;
  description: string;
  location: {
    address: string;
    city: string;
    state?: string;
    country: string;
    coordinates?: {
      type: string;
      coordinates: [number, number];
    };
  };
  price: number;
  images: string[];
  status: PropertyStatus;
  type: PropertyType;
  owner: {
    id: string;
    name: string;
    email: string;
  };
  views: number;
  favoritesCount: number;
  metadata?: Record<string, any>;
  publishedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  isFavorited?: boolean;
  favoritedByCurrentUser?: boolean;
  tenant?: {
    id: string;
    name: string;
    slug: string;
  };

  static fromEntity(entity: PropertyEntity, userId?: string): PropertyResponse {
    const response = new PropertyResponse();
    response.id = entity._id.toString();
    response.title = entity.title;
    response.description = entity.description;
    response.location = {
      address: entity.location.address,
      city: entity.location.city,
      state: entity.location.state,
      country: entity.location.country,
    };
    
    if (entity.location.coordinates) {
      response.location.coordinates = {
        type: entity.location.coordinates.type || 'Point',
        coordinates: entity.location.coordinates.coordinates,
      };
    }
    
    response.price = entity.price;
    response.images = entity.images;
    response.status = entity.status;
    response.type = entity.type;
    
    // Check if owner is populated
    if (entity.owner && typeof entity.owner === 'object' && 'name' in entity.owner) {
      response.owner = {
        id: (entity.owner as any)._id.toString(),
        name: (entity.owner as any).name,
        email: (entity.owner as any).email,
      };
    } else {
      response.owner = {
        id: entity.owner.toString(),
        name: '',
        email: '',
      };
    }
    
    // Check if tenant is populated
    if (entity.tenant && typeof entity.tenant === 'object' && 'name' in entity.tenant) {
      response.tenant = {
        id: (entity.tenant as any)._id.toString(),
        name: (entity.tenant as any).name,
        slug: (entity.tenant as any).slug,
      };
    }
    
    response.views = entity.views;
    response.favoritesCount = entity.favoritesCount;
    response.metadata = entity.metadata;
    response.publishedAt = entity.publishedAt;
    response.createdAt = entity.createdAt;
    response.updatedAt = entity.updatedAt;
    
    // Add favorite status if userId is provided
    if (userId && entity.favoritedBy) {
      response.isFavorited = entity.favoritedBy.some(id => 
        id.toString() === userId || (id as Types.ObjectId).toString() === userId
      );
    }
    
    return response;
  }

  static fromDomain(property: Property, userId?: string): PropertyResponse {
    const response = new PropertyResponse();
    response.id = property.id;
    response.title = property.title;
    response.description = property.description;
    response.location = property.location;
    response.price = property.price;
    response.images = property.images;
    response.status = property.status;
    response.type = property.type;
    response.owner = {
      id: property.ownerId,
      name: '',
      email: '',
    };
    response.views = property.views;
    response.favoritesCount = property.favoritesCount;
    response.metadata = property.metadata;
    response.publishedAt = property.publishedAt;
    response.createdAt = property.createdAt;
    response.updatedAt = property.updatedAt;
    
    // Add favorite status if userId is provided
    if (userId && (property as any).favoritedBy) {
      response.isFavorited = (property as any).favoritedBy.some((id: any) => 
        id.toString() === userId
      );
    }
    
    // Add tenant information if available
    if ((property as any).tenantId) {
      response.tenant = {
        id: (property as any).tenantId,
        name: '',
        slug: '',
      };
    }
    
    return response;
  }
}\n
===== ./roles/dto/create-role.dto.ts =====
import { IsString, IsArray, IsOptional, IsBoolean, ArrayNotEmpty } from 'class-validator';
import { Permission } from '../../shared/constants/permissions';

export class CreateRoleDto {
  @IsString()
  name!: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsArray()
  permissions?: Permission[] = [];

  @IsOptional()
  @IsBoolean()
  isActive?: boolean = true;

  @IsOptional()
  @IsBoolean()
  isSystem?: boolean = false;
}\n
===== ./roles/dto/register.dto.ts =====

import { IsEmail, IsString, MinLength, MaxLength, IsOptional } from 'class-validator';

export class RegisterDto {
  @IsString()
  @MinLength(2)
  @MaxLength(50)
  name: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  @MaxLength(50)
  password: string;

  @IsOptional()
  @IsString()
  @MinLength(2)
  @MaxLength(50)
  company?: string;

  @IsOptional()
  @IsString()
  @MinLength(10)
  @MaxLength(15)
  phone?: string;
}\n
===== ./roles/dto/update-role.dto.ts =====
import { IsString, IsArray, IsOptional, IsBoolean } from 'class-validator';
import { Permission } from '../../shared/constants/permissions';

export class UpdateRoleDto {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsArray()
  permissions?: Permission[];

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}\n
===== ./roles/roles.controller.ts =====
import { 
  Controller, 
  Get, 
  Post, 
  Body, 
  Put, 
  Param, 
  Delete, 
  UseGuards,
  Patch 
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { PermissionsGuard } from '../auth/guards/permissions.guard';
import { RequirePermissions } from '../auth/decorators/permissions.decorator'; // Changed from Permissions to RequirePermissions
import { Permission } from '../shared/constants/permissions';
import { RolesService } from './roles.service';
import { CreateRoleDto } from './dto/create-role.dto';
import { UpdateRoleDto } from './dto/update-role.dto';

@Controller('roles')
@UseGuards(JwtAuthGuard, PermissionsGuard)
export class RolesController {
  constructor(private readonly rolesService: RolesService) {}

  @Get()
  @RequirePermissions(Permission.USER_READ_ALL) 
  
  async findAll() {
    return this.rolesService.findAll();
  }

  @Get(':id')
  @RequirePermissions(Permission.USER_READ_ALL) 
  
  async findOne(@Param('id') id: string) {
    return this.rolesService.findById(id);
  }

  @Post()
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async create(@Body() createRoleDto: CreateRoleDto) {
    return this.rolesService.create(createRoleDto);
  }

  @Put(':id')
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async update(@Param('id') id: string, @Body() updateRoleDto: UpdateRoleDto) {
    return this.rolesService.update(id, updateRoleDto);
  }

  @Delete(':id')
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async remove(@Param('id') id: string) {
    return this.rolesService.remove(id);
  }

  @Patch(':id/permissions/add')
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async addPermission(
    @Param('id') id: string,
    @Body('permission') permission: Permission,
  ) {
    return this.rolesService.addPermission(id, permission);
  }

  @Patch(':id/permissions/remove')
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async removePermission(
    @Param('id') id: string,
    @Body('permission') permission: Permission,
  ) {
    return this.rolesService.removePermission(id, permission);
  }
}\n
===== ./roles/roles.module.ts =====
import { Module, OnModuleInit } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Role, RoleSchema } from './schemas/role.schema';
import { RolesService } from './roles.service';
import { RolesController } from './roles.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Role.name, schema: RoleSchema }]),
  ],
  providers: [RolesService],
  controllers: [RolesController],
  exports: [RolesService],
})
export class RolesModule implements OnModuleInit {
  constructor(private readonly rolesService: RolesService) {}

  async onModuleInit() {
    await this.rolesService.initializeDefaultRoles();
    console.log('Default roles initialized');
  }
}\n
===== ./roles/roles.service.ts =====
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Role, RoleDocument } from './schemas/role.schema';
import { CreateRoleDto } from './dto/create-role.dto';
import { UpdateRoleDto } from './dto/update-role.dto';
import { Permission } from '../shared/constants/permissions';

@Injectable()
export class RolesService {
  constructor(
    @InjectModel(Role.name) private roleModel: Model<RoleDocument>,
  ) {}

  async findAll(): Promise<RoleDocument[]> {
    return this.roleModel.find({ deletedAt: null }).exec();
  }

  async findById(id: string): Promise<RoleDocument> {
    const role = await this.roleModel.findById(id).exec();
    if (!role) {
      throw new NotFoundException(`Role with ID ${id} not found`);
    }
    return role;
  }

  async findByName(name: string): Promise<RoleDocument | null> {
    return this.roleModel.findOne({ name, deletedAt: null }).exec();
  }

  async create(createRoleDto: CreateRoleDto): Promise<RoleDocument> {
    const existingRole = await this.findByName(createRoleDto.name);
    if (existingRole) {
      throw new BadRequestException(`Role with name ${createRoleDto.name} already exists`);
    }

    const role = new this.roleModel(createRoleDto);
    return role.save();
  }

  async update(id: string, updateRoleDto: UpdateRoleDto): Promise<RoleDocument> {
    const role = await this.findById(id);
    
    if (role.isSystem) {
      throw new BadRequestException('System roles cannot be modified');
    }

    if (updateRoleDto.name && updateRoleDto.name !== role.name) {
      const existingRole = await this.findByName(updateRoleDto.name);
      if (existingRole && existingRole._id.toString() !== id) {
        throw new BadRequestException(`Role with name ${updateRoleDto.name} already exists`);
      }
    }

    Object.assign(role, updateRoleDto);
    return role.save();
  }

  async remove(id: string): Promise<void> {
    const role = await this.findById(id);
    
    if (role.isSystem) {
      throw new BadRequestException('System roles cannot be deleted');
    }

    role.deletedAt = new Date();
    await role.save();
  }

  async addPermission(id: string, permission: Permission): Promise<RoleDocument> {
    const role = await this.findById(id);
    
    if (!role.permissions.includes(permission)) {
      role.permissions.push(permission);
      await role.save();
    }
    
    return role;
  }

  async removePermission(id: string, permission: Permission): Promise<RoleDocument> {
    const role = await this.findById(id);
    
    if (role.isSystem) {
      throw new BadRequestException('Cannot modify permissions of system roles');
    }

    role.permissions = role.permissions.filter(p => p !== permission);
    return role.save();
  }

  async getRolePermissions(id: string): Promise<Permission[]> {
    const role = await this.findById(id);
    return role.permissions;
  }

  async initializeDefaultRoles(): Promise<void> {
    const defaultRoles = [
      {
        name: 'admin',
        description: 'System administrator with full access',
        permissions: [
          Permission.PROPERTY_READ_ALL,
          Permission.PROPERTY_UPDATE_ALL,
          Permission.PROPERTY_DELETE_ALL,
          Permission.USER_READ_ALL,
          Permission.USER_UPDATE_ALL,
          Permission.SYSTEM_METRICS_READ,
          Permission.SYSTEM_CONFIG_UPDATE,
        ],
        isSystem: true,
      },
      {
        name: 'property_owner',
        description: 'Property owner who can create and manage properties',
        permissions: [
          Permission.PROPERTY_CREATE,
          Permission.PROPERTY_READ_OWN,
          Permission.PROPERTY_UPDATE_OWN,
          Permission.PROPERTY_DELETE_OWN,
          Permission.PROPERTY_PUBLISH,
          Permission.PROPERTY_ARCHIVE,
          Permission.USER_READ_OWN,
          Permission.USER_UPDATE_OWN,
          Permission.FAVORITE_CREATE,
          Permission.FAVORITE_READ,
          Permission.FAVORITE_DELETE,
        ],
        isSystem: true,
      },
      {
        name: 'regular_user',
        description: 'Regular user who can view properties and save favorites',
        permissions: [
          Permission.USER_READ_OWN,
          Permission.USER_UPDATE_OWN,
          Permission.FAVORITE_CREATE,
          Permission.FAVORITE_READ,
          Permission.FAVORITE_DELETE,
        ],
        isSystem: true,
      },
    ];

    for (const roleData of defaultRoles) {
      const existingRole = await this.findByName(roleData.name);
      if (!existingRole) {
        await this.create(roleData as CreateRoleDto);
      }
    }
  }
}\n
===== ./roles/schemas/role.schema.ts =====
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { Permission } from '../../shared/constants/permissions';

export type RoleDocument = Role & Document;

// Define interface for transformed object
interface RoleTransformed {
  [key: string]: any;
  __v?: number;
}

@Schema({
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: (_, ret: RoleTransformed) => {
      // Use destructuring to safely remove __v
      const { __v, ...rest } = ret;
      return rest;
    },
  },
})
export class Role extends Document {
  @Prop({ required: true, unique: true, trim: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ 
    type: [String], 
    enum: Object.values(Permission),
    default: []
  })
  permissions: Permission[];

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isSystem: boolean; // System roles cannot be deleted

  @Prop()
  deletedAt?: Date;

  createdAt: Date;
  updatedAt: Date;
}

export const RoleSchema = SchemaFactory.createForClass(Role);

// Indexes
RoleSchema.index({ name: 1 }, { unique: true });
RoleSchema.index({ isActive: 1 });
RoleSchema.index({ isSystem: 1 });
RoleSchema.index({ deletedAt: 1 });

// Add method to remove __v
RoleSchema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.__v;
  return obj;
};\n
===== ./seeds/seeds.module.ts =====
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SeedsService } from './seeds.service';
import { Role, RoleSchema } from '../roles/schemas/role.schema';
import { Tenant, TenantSchema } from '../tenants/schemas/tenant.schema';
import { User, UserSchema } from '../users/schemas/user.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Role.name, schema: RoleSchema },
      { name: Tenant.name, schema: TenantSchema },
      { name: User.name, schema: UserSchema },
    ]),
  ],
  providers: [SeedsService],
  exports: [SeedsService],
})
export class SeedsModule {}\n
===== ./seeds/seeds.service.ts =====
import { Injectable, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Role } from '../roles/schemas/role.schema';
import { Tenant } from '../tenants/schemas/tenant.schema';
import { User } from '../users/schemas/user.schema';
import * as bcrypt from 'bcrypt';

@Injectable()
export class SeedsService implements OnModuleInit {
  constructor(
    private configService: ConfigService,
    @InjectModel(Role.name) private roleModel: Model<Role>,
    @InjectModel(Tenant.name) private tenantModel: Model<Tenant>,
    @InjectModel(User.name) private userModel: Model<User>,
  ) {}

  async onModuleInit() {
    console.log('üöÄ Starting database seeding...');
    
    // 1. Ensure default roles exist
    await this.seedDefaultRoles();
    
    // 2. Seed default tenant
    const defaultTenant = await this.seedDefaultTenant();
    
    // 3. Seed admin user from environment variables
    await this.seedAdminUser(defaultTenant);
    
    console.log('‚úÖ Database seeding completed');
  }

  private async seedDefaultRoles() {
    console.log('üìã Checking default roles...');
    
    const defaultRoles = [
      {
        name: 'admin',
        description: 'System administrator with full access',
        permissions: [
          'property.read.all',
          'property.update.all',
          'property.delete.all',
          'user.read.all',
          'user.update.all',
          'system.metrics.read',
          'system.config.update',
        ],
        isSystem: true,
      },
      {
        name: 'property_owner',
        description: 'Property owner who can create and manage properties',
        permissions: [
          'property.create',
          'property.read.own',
          'property.update.own',
          'property.delete.own',
          'property.publish',
          'property.archive',
          'user.read.own',
          'user.update.own',
          'favorite.create',
          'favorite.read',
          'favorite.delete',
        ],
        isSystem: true,
      },
      {
        name: 'regular_user',
        description: 'Regular user who can view properties and save favorites',
        permissions: [
          'user.read.own',
          'user.update.own',
          'favorite.create',
          'favorite.read',
          'favorite.delete',
        ],
        isSystem: true,
      },
    ];

    for (const roleData of defaultRoles) {
      const existingRole = await this.roleModel.findOne({ name: roleData.name });
      if (!existingRole) {
        await this.roleModel.create(roleData);
        console.log(`‚úÖ Created role: ${roleData.name}`);
      } else {
        console.log(`‚úÖ Role already exists: ${roleData.name}`);
      }
    }
  }

  private async seedDefaultTenant() {
    const defaultTenantSlug = this.configService.get('DEFAULT_TENANT_SLUG', 'main');
    const defaultTenantName = this.configService.get('DEFAULT_TENANT_NAME', 'Main Platform');
    
    let tenant = await this.tenantModel.findOne({ slug: defaultTenantSlug });
    
    if (!tenant) {
      tenant = await this.tenantModel.create({
        name: defaultTenantName,
        slug: defaultTenantSlug,
        description: 'Default platform tenant',
        isActive: true,
      });
      console.log(`‚úÖ Default tenant created: ${defaultTenantName}`);
    } else {
      console.log(`‚úÖ Default tenant already exists: ${defaultTenantName}`);
    }
    
    return tenant;
  }

  private async seedAdminUser(defaultTenant: any) {
    const adminEmail = this.configService.get('ADMIN_EMAIL');
    const adminPassword = this.configService.get('ADMIN_PASSWORD');
    const adminName = this.configService.get('ADMIN_NAME', 'Super Admin');

    if (!adminEmail || !adminPassword) {
      console.warn('‚ö†Ô∏è  Admin credentials not set in environment variables');
      console.warn('   Set ADMIN_EMAIL and ADMIN_PASSWORD in .env file');
      return;
    }

    try {
      // Check if admin already exists
      const existingAdmin = await this.userModel.findOne({ email: adminEmail });
      
      if (existingAdmin) {
        console.log(`‚úÖ Admin user already exists: ${adminEmail}`);
        return;
      }

      // Get admin role
      const adminRole = await this.roleModel.findOne({ name: 'admin' });
      
      if (!adminRole) {
        console.error('‚ùå Admin role not found');
        return;
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(adminPassword, 10);

      // Create admin user
      const adminUserData = {
        name: adminName,
        email: adminEmail,
        password: hashedPassword,
        roles: [adminRole._id],
        tenant: defaultTenant._id,
        isActive: true,
      };

      await this.userModel.create(adminUserData);

      console.log(`‚úÖ Super Admin user created: ${adminEmail}`);
      console.log(`   Name: ${adminName}`);
      console.log(`   Tenant: ${defaultTenant.name}`);
      
    } catch (error) {
      console.error('‚ùå Failed to create admin user:', error.message);
    }
  }
}\n
===== ./shared/constants/permissions.ts =====
export enum Permission {
  // Property Permissions
  PROPERTY_CREATE = 'property.create',
  PROPERTY_READ_OWN = 'property.read.own',
  PROPERTY_READ_ALL = 'property.read.all',
  PROPERTY_UPDATE_OWN = 'property.update.own',
  PROPERTY_UPDATE_ALL = 'property.update.all',
  PROPERTY_DELETE_OWN = 'property.delete.own',
  PROPERTY_DELETE_ALL = 'property.delete.all',
  PROPERTY_PUBLISH = 'property.publish',
  PROPERTY_ARCHIVE = 'property.archive',
  
  // User Permissions
  USER_READ_OWN = 'user.read.own',
  USER_READ_ALL = 'user.read.all',
  USER_UPDATE_OWN = 'user.update.own',
  USER_UPDATE_ALL = 'user.update.all',
  
  // Admin Permissions
  SYSTEM_METRICS_READ = 'system.metrics.read',
  SYSTEM_CONFIG_UPDATE = 'system.config.update',
  
  // Favorite Permissions
  FAVORITE_CREATE = 'favorite.create',
  FAVORITE_READ = 'favorite.read',
  FAVORITE_DELETE = 'favorite.delete',
}

// Permission groups for common user types
export const PermissionGroups = {
  ADMIN: [
    Permission.PROPERTY_READ_ALL,
    Permission.PROPERTY_UPDATE_ALL,
    Permission.PROPERTY_DELETE_ALL,
    Permission.USER_READ_ALL,
    Permission.USER_UPDATE_ALL,
    Permission.SYSTEM_METRICS_READ,
    Permission.SYSTEM_CONFIG_UPDATE,
  ],
  PROPERTY_OWNER: [
    Permission.PROPERTY_CREATE,
    Permission.PROPERTY_READ_OWN,
    Permission.PROPERTY_UPDATE_OWN,
    Permission.PROPERTY_DELETE_OWN,
    Permission.PROPERTY_PUBLISH,
    Permission.PROPERTY_ARCHIVE,
    Permission.USER_READ_OWN,
    Permission.USER_UPDATE_OWN,
    Permission.FAVORITE_CREATE,
    Permission.FAVORITE_READ,
    Permission.FAVORITE_DELETE,
  ],
  REGULAR_USER: [
    Permission.PROPERTY_READ_OWN, 
    Permission.USER_READ_OWN,
    Permission.USER_UPDATE_OWN,
    Permission.FAVORITE_CREATE,
    Permission.FAVORITE_READ,
    Permission.FAVORITE_DELETE,
  ],
};\n
===== ./shared/exceptions/exceptions.interface.ts =====
export interface IFormatExceptionMessage {
  message: string;
  code_error?: number;
}
export interface IException {
  badRequestException(data: IFormatExceptionMessage): void;
  internalServerErrorException(data?: IFormatExceptionMessage): void;
  forbiddenException(data?: IFormatExceptionMessage): void;
  UnauthorizedException(data?: IFormatExceptionMessage): void;
}\n
===== ./shared/infrastructure/exceptions/exceptions.module.ts =====
import { Module } from '@nestjs/common';
import { ExceptionsService } from './exceptions.service';
@Module({
  providers: [ExceptionsService],
  exports: [ExceptionsService],
})
export class ExceptionsModule {}\n
===== ./shared/infrastructure/exceptions/exceptions.service.ts =====
import {
  BadRequestException,
  ForbiddenException,
  Injectable,
  InternalServerErrorException,
  UnauthorizedException,
} from '@nestjs/common';
import { IException, IFormatExceptionMessage } from 'src/shared/exceptions/exceptions.interface';
@Injectable()
export class ExceptionsService implements IException {
  badRequestException(data: IFormatExceptionMessage): void {
    throw new BadRequestException(data);
  }
  internalServerErrorException(data?: IFormatExceptionMessage): void {
    throw new InternalServerErrorException(data);
  }
  forbiddenException(data?: IFormatExceptionMessage): void {
    throw new ForbiddenException(data);
  }
  UnauthorizedException(data?: IFormatExceptionMessage): void {
    throw new UnauthorizedException(data);
  }
}\n
===== ./shared/infrastructure/filter/exception.filter.ts =====
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { LoggerService } from '../logger/logger.service';

interface IError {
  message: string;
  code_error: string | null;
}

@Catch()
export class AllExceptionFilter implements ExceptionFilter {
  constructor(private readonly logger: LoggerService) {}

  catch(exception: any, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request: any = ctx.getRequest();

    const status = exception instanceof HttpException 
      ? exception.getStatus() 
      : HttpStatus.INTERNAL_SERVER_ERROR;

    const message: IError = exception instanceof HttpException
      ? {
          message: 
            typeof exception.getResponse() === 'object' && exception.getResponse() !== null
              ? (exception.getResponse() as any).message || 'Unknown error'
              : exception.message,
          code_error: 
            typeof exception.getResponse() === 'object' && exception.getResponse() !== null
              ? (exception.getResponse() as any).code_error || null
              : null,
        }
      : { 
          message: (exception as Error).message || 'Internal server error', 
          code_error: null 
        };

    const responseData = {
      ...{
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      },
      ...message,
    };

    this.logMessage(request, message, status, exception);
    response.status(status).json(responseData);
  }

  private logMessage(request: any, message: IError, status: number, exception: any): void {
    const logMessage = `method=${request.method} status=${status} code_error=${message.code_error || 'null'} message=${message.message || 'null'}`;

    if (status === HttpStatus.INTERNAL_SERVER_ERROR) {
      this.logger.error(
        `End Request for ${request.path}`,
        logMessage,
        status >= 500 ? exception.stack : '',
      );
    } else {
      this.logger.warn(
        `End Request for ${request.path}`,
        logMessage,
      );
    }
  }
}\n
===== ./shared/infrastructure/filter/http-exception.filter.ts =====
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: exception.message || 'Internal server error',
    });
  }
}\n
===== ./shared/infrastructure/interceptors/logger.interceptor.ts =====
import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { LoggerService } from '../logger/logger.service';
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private readonly logger: LoggerService) {}
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const now = Date.now();
    const httpContext = context.switchToHttp();
    const request = httpContext.getRequest();
    const ip = this.getIP(request);
    this.logger.log(`Incoming Request on ${request.path}`, `method=${request.method} ip=${ip}`);
    return next.handle().pipe(
      tap(() => {
        this.logger.log(
          `End Request for ${request.path}`,
          `method=${request.method} ip=${ip} duration=${Date.now() - now}ms`,
        );
      }),
    );
  }
  private getIP(request: any): string {
    let ip: string;
    const ipAddr = request.headers['x-forwarded-for'];
    if (ipAddr) {
      const list = ipAddr.split(',');
      ip = list[list.length - 1];
    } else {
      ip = request.connection.remoteAddress;
    }
    return ip.replace('::ffff:', '');
  }
}\n
===== ./shared/infrastructure/interceptors/response.interceptor.ts =====
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { ApiProperty } from '@nestjs/swagger';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
export class ResponseFormat<T> {
  @ApiProperty()
  isArray: boolean;
  @ApiProperty()
  path: string;
  @ApiProperty()
  duration: string;
  @ApiProperty()
  method: string;
  data: T;
}
@Injectable()
export class ResponseInterceptor<T> implements NestInterceptor<T, ResponseFormat<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<ResponseFormat<T>> {
    const now = Date.now();
    const httpContext = context.switchToHttp();
    const request = httpContext.getRequest();
    return next.handle().pipe(
      map((data) => ({
        data,
        isArray: Array.isArray(data),
        path: request.path,
        duration: `${Date.now() - now}ms`,
        method: request.method,
      })),
    );
  }
}\n
===== ./shared/infrastructure/logger/logger.module.ts =====
import { Module } from '@nestjs/common';
import { LoggerService } from './logger.service';
@Module({
  providers: [LoggerService],
  exports: [LoggerService],
})
export class LoggerModule {}\n
===== ./shared/infrastructure/logger/logger.service.ts =====
import { Injectable, ConsoleLogger } from '@nestjs/common';
import { ILogger } from 'src/shared/logger/logger.interface';

@Injectable()
export class LoggerService extends ConsoleLogger implements ILogger {
  debug(context: string, message: string) {
    if (process.env.NODE_ENV !== 'production') {
      super.debug(`[DEBUG] ${message}`, context);
    }
  }
  
  log(context: string, message: string) {
    super.log(`[INFO] ${message}`, context);
  }
  
  error(context: string, message: string, trace?: string) {
    super.error(`[ERROR] ${message}`, trace, context);
  }
  
  warn(context: string, message: string) {
    super.warn(`[WARN] ${message}`, context);
  }
  
  verbose(context: string, message: string) {
    if (process.env.NODE_ENV !== 'production') {
      super.verbose(`[VERBOSE] ${message}`, context);
    }
  }
}\n
===== ./shared/logger/logger.interface.ts =====
export interface ILogger {
  debug(context: string, message: string): void;
  log(context: string, message: string): void;
  error(context: string, message: string, trace?: string): void;
  warn(context: string, message: string): void;
  verbose(context: string, message: string): void;
}\n
===== ./tenants/dto/create-tenant.dto.ts =====

import { IsString, IsOptional, IsBoolean, IsArray, IsObject } from 'class-validator';

export class CreateTenantDto {
  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  slug?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean = true;

  @IsOptional()
  @IsString()
  owner?: string;

  @IsOptional()
  @IsObject()
  settings?: {
    maxProperties?: number;
    maxUsers?: number;
    allowedPropertyTypes?: string[];
    customDomain?: string;
  };

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  allowedDomains?: string[];
}\n
===== ./tenants/dto/update-tenant.dto.ts =====

import { PartialType } from '@nestjs/mapped-types';
import { CreateTenantDto } from './create-tenant.dto';

export class UpdateTenantDto extends PartialType(CreateTenantDto) {}\n
===== ./tenants/schemas/tenant.schema.ts =====
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type TenantDocument = Tenant & Document;

interface TenantToJSON {
  _id: Types.ObjectId;
  __v: number;
  [key: string]: any;
}

@Schema({
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret: TenantToJSON) {
      const { _id, __v, ...rest } = ret;
      return {
        id: _id.toString(),
        ...rest
      };
    },
  },
})
export class Tenant extends Document {
  @Prop({ required: true, unique: true, trim: true })
  name: string;

  @Prop({ required: true, unique: true, trim: true })
  slug: string; 

  @Prop({ required: true })
  description: string;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ type: Types.ObjectId, ref: 'User' })
  owner: Types.ObjectId;

  @Prop({ type: Object, default: {} })
  settings: {
    maxProperties: number;
    maxUsers: number;
    allowedPropertyTypes: string[];
    customDomain?: string;
  };

  @Prop({ type: [String], default: [] })
  allowedDomains: string[];

  @Prop()
  deletedAt?: Date;

  createdAt: Date;
  updatedAt: Date;
}

export const TenantSchema = SchemaFactory.createForClass(Tenant);

// Indexes
TenantSchema.index({ slug: 1 }, { unique: true });
TenantSchema.index({ owner: 1 });
TenantSchema.index({ isActive: 1 });\n
===== ./tenants/tenant.middleware.ts =====
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Response, NextFunction } from 'express';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Tenant, TenantDocument } from './schemas/tenant.schema';
import { IRequestWithTenant } from '../common/interfaces/request.interface';

@Injectable()
export class TenantMiddleware implements NestMiddleware {
  constructor(
    @InjectModel(Tenant.name) private tenantModel: Model<TenantDocument>,
  ) {}

  async use(req: IRequestWithTenant, res: Response, next: NextFunction) {
    // Try multiple tenant identification methods
    const tenantIdentifier = 
      req.headers['x-tenant-id']?.toString() || 
      req.headers['tenant-id']?.toString() ||
      req.query.tenant?.toString() ||
      req.subdomains[0] || // Subdomain multi-tenancy
      'main'; // Default tenant

    try {
      let tenant: TenantDocument | null = null;
      
      if (Types.ObjectId.isValid(tenantIdentifier)) {
        tenant = await this.tenantModel.findOne({
          _id: new Types.ObjectId(tenantIdentifier),
          isActive: true,
          deletedAt: null,
        });
      } else {
        tenant = await this.tenantModel.findOne({
          slug: tenantIdentifier,
          isActive: true,
          deletedAt: null,
        });
      }

      if (!tenant) {
        // If tenant not found, use default tenant
        tenant = await this.tenantModel.findOne({
          slug: 'main',
          isActive: true,
          deletedAt: null,
        });
      }

      if (tenant) {
        req.tenant = tenant;
        req.tenantId = tenant._id.toString();
        
        // Set tenant context for all downstream services
        res.setHeader('X-Tenant-ID', tenant._id.toString());
        res.setHeader('X-Tenant-Name', tenant.name);
      }
    } catch (error) {
      console.error('Tenant middleware error:', error);
      // Continue without tenant context
    }

    next();
  }
}\n
===== ./tenants/tenants.controller.ts =====
import { 
  Controller, 
  Get, 
  Post, 
  Body, 
  Put, 
  Param, 
  Delete, 
  UseGuards,
  Query 
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { PermissionsGuard } from '../auth/guards/permissions.guard';
import { RequirePermissions } from '../auth/decorators/permissions.decorator'; // Changed from Permissions to RequirePermissions
import { GetUser } from '../auth/decorators/get-user.decorator';
import { Permission } from '../shared/constants/permissions';
import { TenantsService } from './tenants.service';

@Controller('tenants')
export class TenantsController {
  constructor(private readonly tenantsService: TenantsService) {}

  @Get()
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async findAll() {
    return this.tenantsService.findAll();
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard)
  async findOne(@Param('id') id: string, @GetUser() user: any) {
    const tenant = await this.tenantsService.findById(id);
    const isAdmin = user.permissions.includes(Permission.SYSTEM_CONFIG_UPDATE);
    
    if (!isAdmin && user.tenantId !== tenant._id.toString()) {
      throw new Error('Insufficient permissions');
    }
    
    return tenant;
  }

  @Post()
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async create(@Body() tenantData: any, @GetUser() user: any) {
    return this.tenantsService.create({
      ...tenantData,
      owner: user.userId,
    });
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async update(@Param('id') id: string, @Body() updateData: any) {
    return this.tenantsService.update(id, updateData);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, PermissionsGuard)
  @RequirePermissions(Permission.SYSTEM_CONFIG_UPDATE) 
  
  async remove(@Param('id') id: string) {
    await this.tenantsService.remove(id);
    return { message: 'Tenant deleted successfully' };
  }
}\n
===== ./tenants/tenants.module.ts =====
import { Module, NestModule, MiddlewareConsumer, RequestMethod } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Tenant, TenantSchema } from './schemas/tenant.schema';
import { TenantsService } from './tenants.service';
import { TenantsController } from './tenants.controller';
import { TenantMiddleware } from './tenant.middleware';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Tenant.name, schema: TenantSchema }]),
  ],
  providers: [TenantsService, TenantMiddleware],
  controllers: [TenantsController],
  exports: [TenantsService, TenantMiddleware, MongooseModule],
})
export class TenantsModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(TenantMiddleware)
      .exclude(
        { path: 'api/v1/auth/(.*)', method: RequestMethod.ALL },
        { path: 'api/v1/docs/(.*)', method: RequestMethod.ALL },
        { path: 'api/v1/health', method: RequestMethod.GET },
      )
      .forRoutes('*');
  }
}\n
===== ./tenants/tenants.service.ts =====
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Tenant, TenantDocument } from './schemas/tenant.schema';
import { CreateTenantDto } from './dto/create-tenant.dto';
import { UpdateTenantDto } from './dto/update-tenant.dto';

@Injectable()
export class TenantsService {
  constructor(
    @InjectModel(Tenant.name) private tenantModel: Model<Tenant>,
  ) {}

  async create(createTenantDto: CreateTenantDto): Promise<Tenant> {
    // Generate slug if not provided
    if (!createTenantDto.slug && createTenantDto.name) {
      createTenantDto.slug = createTenantDto.name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    }

    if (!createTenantDto.slug) {
      throw new BadRequestException('Tenant slug is required');
    }

    // Check if slug already exists
    const existingTenant = await this.tenantModel.findOne({ 
      slug: createTenantDto.slug 
    }).exec();

    if (existingTenant) {
      throw new BadRequestException(`Tenant with slug '${createTenantDto.slug}' already exists`);
    }

    const tenant = new this.tenantModel(createTenantDto);
    return tenant.save();
  }

  async findAll(): Promise<Tenant[]> {
    return this.tenantModel
      .find({ deletedAt: null })
      .populate('owner', 'name email')
      .exec();
  }

  async findById(id: string): Promise<Tenant> {
    const tenant = await this.tenantModel
      .findById(id)
      .populate('owner', 'name email')
      .exec();

    if (!tenant) {
      throw new NotFoundException(`Tenant with ID ${id} not found`);
    }

    return tenant;
  }

  async findBySlug(slug: string): Promise<Tenant | null> {
    return this.tenantModel
      .findOne({ slug, deletedAt: null })
      .populate('owner', 'name email')
      .exec();
  }

  async update(id: string, updateTenantDto: UpdateTenantDto): Promise<Tenant> {
    const tenant = await this.findById(id);

    // Update slug carefully
    if (updateTenantDto.slug && updateTenantDto.slug !== tenant.slug) {
      const existingTenant = await this.findBySlug(updateTenantDto.slug);
      if (existingTenant) {
        throw new BadRequestException(`Tenant with slug '${updateTenantDto.slug}' already exists`);
      }
    }

    Object.assign(tenant, updateTenantDto);
    return tenant.save();
  }

  async remove(id: string): Promise<void> {
    const tenant = await this.findById(id);
    tenant.deletedAt = new Date();
    await tenant.save();
  }

  async getDefaultTenant(): Promise<Tenant> {
    let tenant = await this.tenantModel
      .findOne({ isActive: true, deletedAt: null })
      .sort({ createdAt: 1 })
      .exec();

    if (!tenant) {
      // Create a default tenant if none exists
      const newTenant = await this.create({
        name: 'Main Platform',
        slug: 'main',
        description: 'Default platform tenant',
        isActive: true,
      });
      return newTenant;
    }

    return tenant;
  }

  async getTenantUsersCount(tenantId: string): Promise<number> {
    // We'll need to import UserModel or inject it
    // For now, we'll return 0 and fix later with proper dependency
    return 0;
  }

  async getTenantPropertiesCount(tenantId: string): Promise<number> {
    // We'll need to import PropertyModel or inject it
    return 0;
  }
}\n
===== ./users/dto/create-user.dto.ts =====
import { IsString, IsEmail, IsOptional, IsMongoId, IsArray, IsBoolean } from 'class-validator';
import { Types } from 'mongoose';

export class CreateUserDto {
  @IsString()
  name: string;

  @IsEmail()
  email: string;

  @IsString()
  password: string;

  @IsOptional()
  @IsString()
  roleName?: string;

  @IsOptional()
  @IsMongoId()
  tenant?: Types.ObjectId;

  @IsOptional()
  @IsString()
  profileImage?: string;

  @IsOptional()
  metadata?: {
    phone?: string;
    bio?: string;
    preferences?: Record<string, any>;
  };
}\n
===== ./users/schemas/user.schema.ts =====

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { Exclude } from 'class-transformer';

export type UserDocument = User & Document;

interface UserTransformed {
  [key: string]: any;
  password?: string;
  __v?: number;
}

@Schema({
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: (doc, ret: UserTransformed) => {
      const { password, __v, ...rest } = ret;
      return rest;
    },
  },
})
export class User extends Document {
  @Prop({ required: true, trim: true })
  name: string;

  @Prop({ 
    required: true, 
    unique: true, 
    lowercase: true, 
    trim: true
  })
  email: string;

  @Prop({ required: true })
  @Exclude()
  password: string;

  @Prop({ type: [{ type: Types.ObjectId, ref: 'Role' }], default: [] })
  roles: Types.ObjectId[];

  @Prop({ type: Types.ObjectId, ref: 'Tenant', required: true, index: true })
  tenant: Types.ObjectId;

  @Prop({ default: true })
  isActive: boolean;

  @Prop()
  profileImage?: string;

  @Prop({ type: Object })
  metadata?: {
    phone?: string;
    bio?: string;
    preferences?: Record<string, any>;
  };

  @Prop()
  lastLoginAt?: Date;

  @Prop()
  deletedAt?: Date;

  @Prop()
  createdAt: Date;

  @Prop()
  updatedAt: Date;

  toSafeObject() {
    const obj = this.toObject();
    const { password, __v, ...safeObj } = obj;
    return safeObj;
  }
}

export const UserSchema = SchemaFactory.createForClass(User);

UserSchema.index({ email: 1 }, { unique: true });
UserSchema.index({ tenant: 1, email: 1 }, { unique: true });
UserSchema.index({ roles: 1 });
UserSchema.index({ deletedAt: 1 });
UserSchema.index({ isActive: 1 });

UserSchema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.password;
  delete obj.__v;
  return obj;
};\n
===== ./users/users.controller.ts =====
import { Controller, Get, Post, Body, Put, Param, Delete, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { PermissionsGuard } from '../auth/guards/permissions.guard';
import { RequirePermissions } from '../auth/decorators/permissions.decorator';
import { GetUser } from '../auth/decorators/get-user.decorator';
import { Permission } from '../shared/constants/permissions';
import { UsersService } from './users.service';

@Controller('users')
@UseGuards(JwtAuthGuard)
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get('profile')
  async getProfile(@GetUser() user: any) {
    return this.usersService.findByIdOrThrow(user.userId);
  }

  @Get()
  @UseGuards(PermissionsGuard)
  @RequirePermissions(Permission.USER_READ_ALL)
  async findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  @UseGuards(PermissionsGuard)
  @RequirePermissions(Permission.USER_READ_ALL)
  async findOne(@Param('id') id: string) {
    return this.usersService.findByIdOrThrow(id);
  }

  @Put('profile')
  async updateProfile(@GetUser() user: any, @Body() updateData: any) {
    return this.usersService.update(user.userId, updateData);
  }

  @Delete(':id')
  @UseGuards(PermissionsGuard)
  @RequirePermissions(Permission.USER_UPDATE_ALL)
  async remove(@Param('id') id: string) {
    return this.usersService.remove(id);
  }

  @Post(':userId/roles/:roleId')
  @UseGuards(PermissionsGuard)
  @RequirePermissions(Permission.USER_UPDATE_ALL)
  async addRole(
    @Param('userId') userId: string,
    @Param('roleId') roleId: string,
  ) {
    return this.usersService.addRole(userId, roleId);
  }

  @Delete(':userId/roles/:roleId')
  @UseGuards(PermissionsGuard)
  @RequirePermissions(Permission.USER_UPDATE_ALL)
  async removeRole(
    @Param('userId') userId: string,
    @Param('roleId') roleId: string,
  ) {
    return this.usersService.removeRole(userId, roleId);
  }
}\n
===== ./users/users.module.ts =====
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from './schemas/user.schema';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { Role, RoleSchema } from '../roles/schemas/role.schema';
import { Tenant, TenantSchema } from '../tenants/schemas/tenant.schema';    

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Role.name, schema: RoleSchema },
      { name: Tenant.name, schema: TenantSchema }, 
    ]),
  ],
  providers: [UsersService],
  controllers: [UsersController],
  exports: [UsersService],
})
export class UsersModule {}\n
===== ./users/users.service.ts =====
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { User, UserDocument } from './schemas/user.schema';
import { Role, RoleDocument } from '../roles/schemas/role.schema';
import { Tenant, TenantDocument } from '../tenants/schemas/tenant.schema'; // Add this import
import * as bcrypt from 'bcrypt';
import { CreateUserDto } from './dto/create-user.dto';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    @InjectModel(Role.name) private roleModel: Model<RoleDocument>,
    @InjectModel(Tenant.name) private tenantModel: Model<TenantDocument>, // Add this line
  ) {}

  async findByEmail(email: string): Promise<UserDocument | null> {
    return this.userModel
      .findOne({ email, deletedAt: null })
      .populate('roles', 'name permissions')
      .exec();
  }

  async findById(id: string): Promise<UserDocument | null> {
    return this.userModel
      .findById(id)
      .populate('roles', 'name permissions')
      .select('-password -__v')
      .exec();
  }

  async findByIdOrThrow(id: string): Promise<UserDocument> {
    const user = await this.findById(id);
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async findAll(): Promise<UserDocument[]> {
    return this.userModel
      .find({ deletedAt: null })
      .populate('roles', 'name permissions')
      .select('-password -__v')
      .exec();
  }

  async create(createUserDto: CreateUserDto): Promise<UserDocument> {
    // Hash password if provided
    const hashedPassword = createUserDto.password 
      ? await bcrypt.hash(createUserDto.password, 10)
      : undefined;

    // Handle role assignment
    let roles: Types.ObjectId[] = [];
    
    if (createUserDto.roleName) {
      const role = await this.roleModel.findOne({ name: createUserDto.roleName });
      if (role) {
        roles = [role._id];
      }
    }
    
    // Set default role if not provided
    if (roles.length === 0) {
      const defaultRole = await this.roleModel.findOne({ name: 'regular_user' });
      if (defaultRole) {
        roles = [defaultRole._id];
      }
    }

    // Get or create default tenant
    let tenantId = createUserDto.tenant;
    if (!tenantId) {
      const defaultTenant = await this.tenantModel.findOne({ slug: 'main' });
      if (!defaultTenant) {
        // Create default tenant if it doesn't exist
        const newTenant = await this.tenantModel.create({
          name: 'Main Platform',
          slug: 'main',
          description: 'Default platform tenant',
          isActive: true,
        });
        tenantId = newTenant._id;
      } else {
        tenantId = defaultTenant._id;
      }
    }

    const userData = {
      name: createUserDto.name,
      email: createUserDto.email,
      password: hashedPassword,
      roles,
      tenant: tenantId,
      profileImage: createUserDto.profileImage,
      metadata: createUserDto.metadata,
      isActive: true,
    };

    const user = new this.userModel(userData);
    return user.save();
  }

  async update(id: string, updateData: Partial<User>): Promise<UserDocument> {
    // Don't allow password update through this method
    if (updateData.password) {
      delete updateData.password;
    }

    // Handle role updates
    if (updateData.roles) {
      // Validate all roles exist
      const roles = await this.roleModel.find({ 
        _id: { $in: updateData.roles },
        deletedAt: null 
      });
      if (roles.length !== updateData.roles.length) {
        throw new BadRequestException('One or more roles not found');
      }
    }

    const updated = await this.userModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('roles', 'name permissions')
      .select('-password -__v')
      .exec();

    if (!updated) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }

    return updated;
  }

  async addRole(userId: string, roleId: string): Promise<UserDocument> {
    const user = await this.userModel.findById(userId);
    const role = await this.roleModel.findById(roleId);

    if (!user || !role) {
      throw new NotFoundException('User or role not found');
    }

    // Check if user already has the role
    if (!user.roles.includes(role._id)) {
      user.roles.push(role._id);
      await user.save();
    }

    const updatedUser = await this.findById(userId);
    if (!updatedUser) {
      throw new NotFoundException('User not found after update');
    }
    return updatedUser;
  }

  async removeRole(userId: string, roleId: string): Promise<UserDocument> {
    const user = await this.userModel.findById(userId);

    if (!user) {
      throw new NotFoundException('User not found');
    }

    user.roles = user.roles.filter(role => !role.equals(new Types.ObjectId(roleId)));
    await user.save();

    const updatedUser = await this.findById(userId);
    if (!updatedUser) {
      throw new NotFoundException('User not found after update');
    }
    return updatedUser;
  }

  async getUserPermissions(userId: string): Promise<string[]> {
    const user = await this.userModel
      .findById(userId)
      .populate('roles', 'permissions')
      .exec();

    if (!user) {
      return [];
    }

    // Aggregate permissions from all roles
    const permissions = new Set<string>();
    
    // Handle both populated and non-populated roles
    const roles = user.roles;
    for (const role of roles) {
      if (role && typeof role === 'object') {
        const roleObj = role as any;
        if (roleObj.permissions && Array.isArray(roleObj.permissions)) {
          roleObj.permissions.forEach((permission: string) => {
            permissions.add(permission);
          });
        }
      }
    }

    return Array.from(permissions);
  }

  async remove(id: string): Promise<UserDocument> {
    // Soft delete
    const deleted = await this.userModel
      .findByIdAndUpdate(id, { deletedAt: new Date() }, { new: true })
      .select('-password -__v')
      .exec();

    if (!deleted) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }

    return deleted;
  }

  async updatePassword(id: string, newPassword: string): Promise<void> {
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    await this.userModel.findByIdAndUpdate(id, { password: hashedPassword }).exec();
  }

  async validateUser(email: string, password: string): Promise<UserDocument | null> {
    const user = await this.findByEmail(email);

    if (user && await bcrypt.compare(password, user.password)) {
      return user;
    }

    return null;
  }

  // Add toSafeObject method to UserDocument
  toSafeObject(user: UserDocument): any {
    const obj = user.toObject();
    const { password, __v, ...safeObj } = obj;
    return safeObj;
  }
}\n
